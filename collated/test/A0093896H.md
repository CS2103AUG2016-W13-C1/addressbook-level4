# A0093896H
###### /java/guitests/AddCommandTest.java
``` java
    @Test
    public void addCommandTest() {
        //add one task
        TestTask[] currentList = td.getEmptyTaskList();
        TestTask taskToAdd = TypicalTestTasks.buyMilk;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        //add another task
        taskToAdd = TypicalTestTasks.buyRice;
        assertAddSuccess(taskToAdd, currentList);
        currentList = TestUtil.addTasksToList(currentList, taskToAdd);

        //add duplicate task
        commandBox.runCommand(TypicalTestTasks.buyMilk.getAddCommand());
        assertResultMessage(AddCommand.MESSAGE_DUPLICATE_TASK);
        assertTrue(taskListPanel.isListMatching(currentList));

        //add to empty list
        commandBox.runCommand("clear");
        assertAddSuccess(TypicalTestTasks.buyGroceries);

        //invalid command
        commandBox.runCommand("adds go to town");
        assertResultMessage(Messages.MESSAGE_UNKNOWN_COMMAND);
    }
```
###### /java/guitests/CardStylerTest.java
``` java
public class CardStylerTest {

    private Text name;
    private Text details;
    private Text recurrence;
    private Text onDate;
    private Text byDate;
    private Text tags;
    private Circle priorityLevel;
    
    @Before
    public void setup() {
        name = new Text();
        details = new Text();
        onDate = new Text();
        byDate = new Text();
        tags = new Text();
        recurrence = new Text();       
        priorityLevel = new Circle();
    }
    
    @Test
    public void styleForCompletionTest() {
        CardStyler.styleForCompletion(name, details, onDate, byDate, tags, recurrence, priorityLevel);
        assertEquals(name.getFill(), CardStyler.COMPLETION_COLOR);
        assertEquals(details.getFill(), CardStyler.COMPLETION_COLOR);
        assertEquals(onDate.getFill(), CardStyler.COMPLETION_COLOR);
        assertEquals(byDate.getFill(), CardStyler.COMPLETION_COLOR);
        assertEquals(tags.getFill(), CardStyler.COMPLETION_COLOR);
        assertEquals(recurrence.getFill(), CardStyler.COMPLETION_COLOR);
        
        assertEquals(priorityLevel.getFill(), CardStyler.COMPLETION_PRIORITY_COLOR);
        assertEquals(priorityLevel.getStroke(), CardStyler.COMPLETION_PRIORITY_COLOR);
    }
    
    @Test
    public void styleForOverdueTest() {
        CardStyler.styleForOverdue(name, details, onDate, byDate, tags, recurrence);
        assertEquals(name.getFill(), CardStyler.OVERDUE_COLOR);
        assertEquals(details.getFill(), CardStyler.OVERDUE_COLOR);
        assertEquals(onDate.getFill(), CardStyler.OVERDUE_COLOR);
        assertEquals(byDate.getFill(), CardStyler.OVERDUE_COLOR);
        assertEquals(tags.getFill(), CardStyler.OVERDUE_COLOR);
        assertEquals(recurrence.getFill(), CardStyler.OVERDUE_COLOR);

    }
    
}
```
###### /java/guitests/DeleteCommandTest.java
``` java
    @Test
    public void deleteCommandTest() {
               
        //delete the first in the list
        TestTask[] currentList = td.getTypicalTasks();
        for (TestTask t : currentList) {
            commandBox.runCommand(t.getAddCommand());
        }
        int targetIndex = 1;
        TestTask[] currentRevList = td.getTypicalTasksReverse();
        assertDeleteSuccess(targetIndex, currentRevList);

        //delete the last in the list
        currentRevList = TestUtil.removeTaskFromList(currentRevList, targetIndex);
        targetIndex = currentRevList.length;
        assertDeleteSuccess(targetIndex, currentRevList);

        //delete from the middle of the list
        currentRevList = TestUtil.removeTaskFromList(currentRevList, targetIndex);
        targetIndex = currentRevList.length / 2;
        assertDeleteSuccess(targetIndex, currentRevList);

        //invalid index
        commandBox.runCommand("delete " + currentRevList.length + 1);
        assertResultMessage("The task index provided is invalid");

    }
```
###### /java/guitests/PrettifyDateTest.java
``` java
/**
 * Unit test for PrettifyDate Class
 */
public class PrettifyDateTest {

    @Test
    public void prettifyDateTest() {
        LocalDate ldy = LocalDate.now().minusDays(1);        
        assertEquals(PrettifyDate.prettifyDate(ldy), "Yesterday");
        
        ldy = LocalDate.now().minusDays(2);
        assertEquals(PrettifyDate.prettifyDate(ldy), "2 days ago");
        
        ldy = LocalDate.now().plusDays(2);
        assertEquals(PrettifyDate.prettifyDate(ldy), "2 days later");
    }
    

}
```
###### /java/guitests/UpdateCommandTest.java
``` java
public class UpdateCommandTest extends ToDoListGuiTest {
    
    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test
    public void updateCommandTest() throws IllegalValueException {
        
        TestTask[] currentList = td.getTypicalTasks();
        for (TestTask t : currentList) {
            commandBox.runCommand(t.getAddCommand());
        }
        
        TestTask[] reverseList = td.getTypicalTasksReverse();
        
        //update name
        reverseList[0].setName(new Name("changeName"));
        commandBox.runCommand("update 1 changeName");
        assertUpdateSuccess(reverseList);
        
        //update on date and priority
        reverseList[0].setPriority(new Priority("high"));
        reverseList[0].setOnDate(new TaskDate("12/12/1996", TaskDate.TASK_DATE_ON));
        commandBox.runCommand("update 1 on 12/12/1996 priority high");
        assertUpdateSuccess(reverseList);
        
        //remove detail
        reverseList[0].setDetail(new Detail(""));
        commandBox.runCommand("update 1 ; -");
        assertUpdateSuccess(reverseList);
        
        //full update
        reverseList[1].setName(new Name("this is full update"));
        reverseList[1].setDetail(new Detail("haha"));
        reverseList[1].setOnDate(new TaskDate("tomorrow", TaskDate.TASK_DATE_ON));
        reverseList[1].setByDate(new TaskDate("2 days later", TaskDate.TASK_DATE_BY));
        reverseList[1].setPriority(new Priority("mid"));
        reverseList[1].setRecurrence(new Recurrence(Frequency.WEEK));
        
        commandBox.runCommand("update 2 this is full update "
                + "on tomorrow by 2 days later priority mid every week ; haha");
        
        assertUpdateSuccess(reverseList);
    }
    
    
    /**
     * Check if the expected list is the same as the gui list
     * @param currentList A copy of the expected list of tasks (after undo).
     */
    private void assertUpdateSuccess(TestTask... expectedList) {
        assertTrue(taskListPanel.isListMatching(expectedList));
    }
    
    
}

```
###### /java/seedu/todo/commons/events/EventsTest.java
``` java
public class EventsTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test
    public void jumpToListRequestEvent_test() {
        JumpToListRequestEvent jtlre = new JumpToListRequestEvent(0);
        assertEquals(0, jtlre.targetIndex);
        assertEquals(jtlre.toString(), "JumpToListRequestEvent");
    }
    
    @Test
    public void summaryPanelSelectionEvent_test() {
        SummaryPanelSelectionEvent spse = new SummaryPanelSelectionEvent();
        assertEquals(spse.toString(), "SummaryPanelSelectionEvent");
    }
    
    @Test
    public void weekSummaryPanelSelectionEvent_test() {
        WeekSummaryPanelSelectionEvent wspse = new WeekSummaryPanelSelectionEvent();
        assertEquals(wspse.toString(), "WeekSummaryPanelSelectionEvent");
    }
    
    @Test
    public void tagPanelSelectionEvent_test() throws IllegalValueException {
        Tag tag = new Tag("TEST");
        TagPanelSelectionEvent tpse = new TagPanelSelectionEvent(tag);
        
        assertEquals(tpse.tag, tag);
        assertEquals(tpse.toString(), "TagPanelSelectionEvent");
    }
    
    
}
```
###### /java/seedu/todo/commons/util/DateTimeUtilTest.java
``` java
    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test
    public void isValidDateString() {
        String[] validFormats = {
            "8 Oct 2015", "8/12/2014", "8-12-2000", 
            "2/October/2103", "13 March 2013", "4 May 2013"};
        
        String[] invalidFormats = {"abcd", "adsa"};
        for (String validFormat : validFormats) {
            assertNotNull(DateTimeUtil.parseDateTimeString(validFormat, TaskDate.TASK_DATE_ON));
        }
        for (String invalidFormat : invalidFormats) {
            assertNull(DateTimeUtil.parseDateTimeString(invalidFormat, TaskDate.TASK_DATE_ON));
        }
        
    }
    
    @Test
    public void containsDateField() {
        assertTrue(DateTimeUtil.containsDateField("12/12/1234"));
        assertFalse(DateTimeUtil.containsDateField("12"));
        assertTrue(DateTimeUtil.containsDateField("12/12/1234 12:30"));
    }
    
    @Test
    public void containsTimeField() {
        assertFalse(DateTimeUtil.containsTimeField("12/12/1234"));
        assertTrue(DateTimeUtil.containsTimeField("12:30"));
        assertTrue(DateTimeUtil.containsTimeField("12"));
        assertTrue(DateTimeUtil.containsTimeField("12/12/1234 12:30"));
    }
    
```
###### /java/seedu/todo/commons/util/DateTimeUtilTest.java
``` java
    @Test
    public void parseDateTimeString() {
        LocalDateTime ldt = LocalDateTime.of(1996, 1, 1, 20, 34);
        LocalDateTime ldtNoTime = LocalDateTime.of(1996, 1, 1, 0, 0);
        LocalDateTime ldtNoDate = LocalDateTime.now();
        ldtNoDate = ldtNoDate.of(ldtNoDate.getYear(), ldtNoDate.getMonth(), ldtNoDate.getDayOfMonth(), 20, 34);
        assertEquals(ldt, DateTimeUtil.parseDateTimeString("1/1/1996 20:34", TaskDate.TASK_DATE_ON));
        assertEquals(ldtNoTime, DateTimeUtil.parseDateTimeString("1/1/1996", TaskDate.TASK_DATE_ON));
        assertEquals(ldtNoDate, DateTimeUtil.parseDateTimeString("20:34", TaskDate.TASK_DATE_ON));
    }
    
```
###### /java/seedu/todo/logic/AddLogicTest.java
``` java
/**
 * Test class for the add command's logic
 */
public class AddLogicTest extends CommandLogicTest {

    @Before
    public void add_setup() {}
    
    @Test
    public void execute_add_invalidTaskData() throws IllegalValueException {
        assertCommandBehavior(
                "add Valid Name on vdvd ; a line of details", TaskDate.MESSAGE_DATETIME_CONSTRAINTS);
        assertCommandBehavior(
                "add Valid Name on 12/12/1234 by asdasdsad ; a line of details", TaskDate.MESSAGE_DATETIME_CONSTRAINTS);

        assertCommandBehavior(
                "add ;;", Name.MESSAGE_NAME_CONSTRAINTS);

    }

    @Test
    public void execute_add_fullTask_successful() throws IllegalValueException {
        Task toBeAdded = helper.generateFullTask(0);
        Task toBeAddedRecur = helper.generateTaskWithDates("today 1400", "1600");
        
        expectedTDL.addTask(toBeAdded);
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded), expectedTDL,
                expectedTDL.getTaskList());
        
        expectedTDL.addTask(toBeAddedRecur);
        assertCommandBehavior(helper.generateAddCommandRecurring(toBeAddedRecur),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAddedRecur),
                expectedTDL, expectedTDL.getTaskList());
    }
    
    @Test
    public void execute_add_onTask_successful() throws IllegalValueException {
        
        Task toBeAdded = helper.generateTaskWithDates("today", null);
        Task toBeAddedRecur = helper.generateTaskWithDates("tomorrow", null);
        
        expectedTDL.addTask(toBeAdded);        
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedTDL,
                expectedTDL.getTaskList());
        
        expectedTDL.addTask(toBeAddedRecur);
        assertCommandBehavior(helper.generateAddCommand(toBeAddedRecur),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAddedRecur),
                expectedTDL,
                expectedTDL.getTaskList());
    }

    @Test
    public void execute_add_floatingTask_successful() throws IllegalValueException {
        // setup expectations
        Task toBeAdded = helper.generateTaskWithDates(null, null);        
        expectedTDL.addTask(toBeAdded);

        // execute command and verify result
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedTDL,
                expectedTDL.getTaskList());
    }
    
    @Test
    public void execute_add_deadlineTask_successful() throws IllegalValueException {
        Task toBeAdded = helper.generateTaskWithDates(null, "Tomorrow");        
        expectedTDL.addTask(toBeAdded);
        
        assertCommandBehavior(helper.generateAddCommand(toBeAdded),
                String.format(AddCommand.MESSAGE_SUCCESS, toBeAdded),
                expectedTDL,
                expectedTDL.getTaskList());
    }
    
    @Test
    public void execute_addDuplicate_notAllowed() throws IllegalValueException {
        Task toBeAdded = helper.generateFullTask(0);
        expectedTDL.addTask(toBeAdded);

        model.addTask(toBeAdded); // task already in internal address book
        assertCommandBehavior(
                helper.generateAddCommand(toBeAdded),
                AddCommand.MESSAGE_DUPLICATE_TASK,
                expectedTDL,
                expectedTDL.getTaskList());
    }
}
```
###### /java/seedu/todo/logic/DeleteLogicTest.java
``` java
/**
 * Test class for the delete command's logic
 */
public class DeleteLogicTest extends CommandLogicTest {

    @Before
    public void delete_setup() {}
    
    @Test
    public void execute_deleteInvalidArgsFormat_errorMessageShown() throws IllegalValueException {
        String expectedMessage = String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE);
        assertIncorrectIndexFormatBehaviorForCommand(DeleteCommand.COMMAND_WORD, expectedMessage);
    }

    @Test
    public void execute_deleteIndexNotFound_errorMessageShown() throws Exception {
        assertIndexNotFoundBehaviorForCommand(DeleteCommand.COMMAND_WORD);
    }

    @Test
    public void execute_delete_removesCorrectTask() throws IllegalValueException, TaskNotFoundException {
        TestDataHelper helper = new TestDataHelper();
        List<Task> threeTasks = helper.generateTaskList(3);

        DoDoBird expectedAB = helper.generateToDoList(threeTasks);
        expectedAB.deleteTask(threeTasks.get(1));
        helper.addToModel(model, threeTasks);

        assertCommandBehavior("delete 2",
                String.format(DeleteCommand.MESSAGE_DELETE_TASK_SUCCESS, 2, threeTasks.get(1)),
                expectedAB,
                expectedAB.getTaskList());
    }
}
```
###### /java/seedu/todo/logic/SearchLogicTest.java
``` java
/**
 * Test class for the search command's logic
 */
public class SearchLogicTest extends CommandLogicTest {
    
    private Task t1, t2, t3, t4;
    List<Task> fourTasks, twoTasks;
    
    @Before
    public void search_setup() throws IllegalValueException {
        t1 = helper.generateTaskWithName("bla bla KEY bla");
        t2 = helper.generateTaskWithName("bla key bla bceofeia");
        t3 = helper.generateTaskWithName("KE Y");
        t4 = helper.generateTaskWithName("KEYKEYKEY sduauo");
        
        fourTasks = helper.generateTaskList(t3, t1, t4, t2);
        twoTasks = helper.generateTaskList(t1, t2);
        
    }
    
    @Test
    public void execute_search_all() throws IllegalValueException {
        List<Task> expectedList = helper.generateReverseTaskList(t3, t1, t4, t2);
        
        helper.addToModel(model, fourTasks);
        expectedTDL = helper.generateToDoList(fourTasks);
        
        assertCommandBehavior("search all",
                String.format(SearchCommand.MESSAGE_SUCCESS, "", SearchIndex.ALL, "")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
    }
    
    
    @Test
    public void execute_search_onlyMatchesFullWordsInNames() throws IllegalValueException {
        t2.setCompletion(new Completion(true));
        List<Task> expectedList = helper.generateReverseTaskList(t1);
        List<Task> expectedListDone = helper.generateReverseTaskList(t2);
        
        helper.addToModel(model, fourTasks);
        expectedTDL = helper.generateToDoList(fourTasks);
        
        assertCommandBehavior("search KEY",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE, 
                        SearchIndex.KEYWORD, "KEY")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
        assertCommandBehavior("search KEY done",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.DONE,
                        SearchIndex.KEYWORD, "KEY")
                      + Command.getMessageForTaskListShownSummary(expectedListDone.size()),
                expectedTDL,
                expectedListDone);
    }

    @Test
    public void execute_find_isNotCaseSensitive() throws IllegalValueException {
        List<Task> expectedList = helper.generateReverseTaskList(t1, t2);
        helper.addToModel(model, fourTasks);
        expectedTDL = helper.generateToDoList(fourTasks);
        
        assertCommandBehavior("search KEY",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE, 
                        SearchIndex.KEYWORD, "KEY")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
    }

    @Test
    public void execute_search_matchesIfTagPresent() throws IllegalValueException {        
        t1.addTag(new Tag("school"));
        t2.addTag(new Tag("school"));
        t2.setCompletion(new Completion(true));
        
        DoDoBird expectedTDL = helper.generateToDoList(twoTasks);
        List<Task> expectedList = helper.generateTaskList(t1);
        List<Task> expectedListDone = helper.generateTaskList(t2);
        
        helper.addToModel(model, twoTasks);
        expectedTDL = helper.generateToDoList(twoTasks);
        
        assertCommandBehavior("search tag school",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.TAG, "school")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
        assertCommandBehavior("search tag school done",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.DONE,
                        SearchIndex.TAG, "school")
                      + Command.getMessageForTaskListShownSummary(expectedListDone.size()),
                expectedTDL,
                expectedListDone);
        
    }
  
    
    @Test
    public void execute_search_matchesIfBefore() throws IllegalValueException {
        DoDoBird expectedTDL = helper.generateToDoList(twoTasks);
        List<Task> expectedList = helper.generateReverseTaskList(t1, t2);
        
        helper.addToModel(model, twoTasks);
        expectedTDL = helper.generateToDoList(twoTasks);
        
        assertCommandBehavior("search before 12/12/2019",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.BEFORE, "12/12/2019")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
        t1.setCompletion(new Completion(true));
        List<Task> expectedListDone = helper.generateReverseTaskList(t1);
        assertCommandBehavior("search before 12/12/2019 done",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.DONE,
                        SearchIndex.BEFORE, "12/12/2019")
                      + Command.getMessageForTaskListShownSummary(expectedListDone.size()),
                expectedTDL,
                expectedListDone);
        
        assertCommandBehavior("search before 12/12/2019 all",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.ALL,
                        SearchIndex.BEFORE, "12/12/2019 ")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
    }
    
    @Test
    public void execute_search_matchesIfAfter() throws IllegalValueException {
        expectedTDL = helper.generateToDoList(twoTasks);
        List<Task> expectedList = helper.generateReverseTaskList(t1, t2);
        
        helper.addToModel(model, twoTasks);

        assertCommandBehavior("search after 12/12/2013",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.AFTER, "12/12/2013")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
        t1.setCompletion(new Completion(true));
        List<Task> expectedListDone = helper.generateReverseTaskList(t1);
        assertCommandBehavior("search after 12/12/2013 done",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.DONE,
                        SearchIndex.AFTER, "12/12/2013")
                      + Command.getMessageForTaskListShownSummary(expectedListDone.size()),
                expectedTDL,
                expectedListDone);
        
        assertCommandBehavior("search after 12/12/2013 all",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.ALL,
                        SearchIndex.AFTER, "12/12/2013 ")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
    }
    
    @Test
    public void execute_search_matchesIfFromTill() throws IllegalValueException {
        expectedTDL = helper.generateToDoList(twoTasks);
        List<Task> expectedList = helper.generateReverseTaskList(t1, t2);
        
        helper.addToModel(model, twoTasks);

        assertCommandBehavior("search from 12/12/2013 to 12/12/2019",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.FT, "12/12/2013@12/12/2019")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
    }
    
    @Test
    public void execute_search_matchesIfOn() throws IllegalValueException {
        Task t1 = helper.generateTaskWithDates("today", "2 days later");
        Task t2 = helper.generateTaskWithDates("today", "tomorrow");
        t2.setCompletion(new Completion(true));
        
        List<Task> twoTasks = helper.generateTaskList(t1, t2);
        DoDoBird expectedTDL = helper.generateToDoList(twoTasks);
        
        List<Task> expectedList = helper.generateReverseTaskList(t1);
        List<Task> expectedListDone = helper.generateReverseTaskList(t2);
        List<Task> expectedListAll = helper.generateReverseTaskList(t1, t2);
        
        helper.addToModel(model, twoTasks);

        assertCommandBehavior("search on today",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.ON, "today")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
        assertCommandBehavior("search on today 1400",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.ON, "today 1400")
                      + Command.getMessageForTaskListShownSummary(0),
                expectedTDL,
                (new DoDoBird()).getTaskList());
        
        assertCommandBehavior("search on today done",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.DONE,
                        SearchIndex.ON, "today")
                      + Command.getMessageForTaskListShownSummary(expectedListDone.size()),
                expectedTDL,
                expectedListDone);
        
        assertCommandBehavior("search on today all",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.ALL,
                        SearchIndex.ON, "today ")
                      + Command.getMessageForTaskListShownSummary(expectedListAll.size()),
                expectedTDL,
                expectedListAll);
    }
    
    @Test
    public void execute_search_matchesIfFloating() throws IllegalValueException {
        Task t1 = helper.generateTaskWithDates(null, null);
        Task t2 = helper.generateTaskWithDates("today", "tomorrow");
        
        List<Task> twoTasks = helper.generateTaskList(t1, t2);
        DoDoBird expectedTDL = helper.generateToDoList(twoTasks);
        
        List<Task> expectedList = helper.generateReverseTaskList(t1);
        List<Task> expectedListDone = helper.generateReverseTaskList(t1);
        
        helper.addToModel(model, twoTasks);
        
        assertCommandBehavior("search floating",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.FLOATING, "")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
        t1.setCompletion(new Completion(true));
        assertCommandBehavior("search floating done",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.DONE,
                        SearchIndex.FLOATING, "")
                      + Command.getMessageForTaskListShownSummary(expectedListDone.size()),
                expectedTDL,
                expectedListDone);
        
    }
    
    
    @Test
    public void execute_search_matchesIfDone() throws IllegalValueException {        
        t1.setCompletion(new Completion(true));
        expectedTDL = helper.generateToDoList(twoTasks);
        List<Task> expectedList = helper.generateReverseTaskList(t1);
        
        helper.addToModel(model, twoTasks);

        assertCommandBehavior("search done",
                String.format(SearchCommand.MESSAGE_SUCCESS, "", SearchIndex.DONE, "")
                    + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
    }
    
    
    @Test
    public void execute_search_matchesIfUndone() throws IllegalValueException {        
        t1.setCompletion(new Completion(true));
        expectedTDL = helper.generateToDoList(twoTasks);
        List<Task> expectedList = helper.generateReverseTaskList(t2);
        
        helper.addToModel(model, twoTasks);

        assertCommandBehavior("search",
                String.format(SearchCommand.MESSAGE_SUCCESS, "", SearchIndex.UNDONE, "")
                    + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
    }
    
    @Test
    public void execute_search_matchesPriority() throws IllegalValueException {        
        Task t1 = helper.generateFullTaskPriorityMid(1);
        Task t2 = helper.generateFullTaskPriorityMid(2);
        Task t3 = helper.generateFullTaskPriorityHigh(1);
        
        List<Task> threeTasks = helper.generateTaskList(t1, t2, t3);
        DoDoBird expectedTDL = helper.generateToDoList(threeTasks);
        
        List<Task> expectedList = helper.generateReverseTaskList(t1, t2);
        List<Task> expectedListDone = helper.generateReverseTaskList(t1);
        
        helper.addToModel(model, threeTasks);
        
        assertCommandBehavior("search priority mid",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.UNDONE,
                        SearchIndex.PRIORITY, "mid")
                      + Command.getMessageForTaskListShownSummary(expectedList.size()),
                expectedTDL,
                expectedList);
        
        t1.setCompletion(new Completion(true));
        assertCommandBehavior("search priority mid done",
                String.format(SearchCommand.MESSAGE_SUCCESS, SearchCompletedOption.DONE,
                        SearchIndex.PRIORITY, "mid")
                      + Command.getMessageForTaskListShownSummary(expectedListDone.size()),
                expectedTDL,
                expectedListDone);
    }
    
    
    
}
```
###### /java/seedu/todo/logic/StoreLogicTest.java
``` java
/**
 * Test class for the store and reset command's logic
 */
public class StoreLogicTest extends CommandLogicTest {
    
    @Test
    public void execute_reset() throws IllegalValueException {
        String origLocation = config.getToDoListFilePath();
        logic.execute("reset");
        
        assertEquals(origLocation, config.getToDoListFilePath());
    }
    
    
    @Test
    public void execute_store() throws IllegalValueException {
        logic.execute("store " + alternateFolder.getRoot().getPath());
        String newLocation = config.getToDoListFilePath();
        assertEquals(newLocation, config.getToDoListFilePath());
        
        logic.execute("reset"); //reset config
    }
}
```
###### /java/seedu/todo/model/CompletionTest.java
``` java

/**
 * Test class for task completion 
 */
public class CompletionTest {

    @Test
    public void completion_test() {
        
        Completion c = new Completion();
        assertFalse(c.isCompleted());
        c.toggle();
        assertTrue(c.isCompleted());
        
    }
    
}
```
###### /java/seedu/todo/model/qualifiers/FloatingQualifierTest.java
``` java
/**
 * Test class for FoatingQualifier used in model when searching for floating tasks
 */
public class FloatingQualifierTest {
    private TestDataHelper helper;
    private DoDoBird ddb;
    
    @Before
    public void setup() {
        helper = new TestDataHelper();
        ddb = new DoDoBird();
    }

    @Test
    public void floatingQualifer_test() throws Exception {
        FilteredList<Task> filteredTasks = new FilteredList<>(ddb.getTasks());
        Task toAdd = helper.generateTaskWithDates(null, null);
        ddb.addTask(toAdd);
        
        filteredTasks.setPredicate((new PredicateExpression(
                new FloatingQualifier(SearchCompletedOption.ALL))::satisfies));
        assertEquals(filteredTasks.size(), 1);
        
        toAdd.setCompletion(new Completion(true));
        
        filteredTasks.setPredicate((new PredicateExpression(
                new FloatingQualifier(SearchCompletedOption.UNDONE))::satisfies));
        assertEquals(filteredTasks.size(), 0);
        
        filteredTasks.setPredicate((new PredicateExpression(
                new FloatingQualifier(SearchCompletedOption.DONE))::satisfies));
        assertEquals(filteredTasks.size(), 1);
        
    }
}
```
###### /java/seedu/todo/model/qualifiers/OnDateQualifierTest.java
``` java
/**
 * Test class for OnDateQualifier used in model 
 * when searching for tasks that fall on a certain date
 */
public class OnDateQualifierTest {
    
    TestDataHelper helper;
    DoDoBird ddb;
    
    @Before
    public void setup() {
        helper = new TestDataHelper();
        ddb = new DoDoBird();
    }
    
    @Test
    public void onDateQualifer_test() throws Exception {
        FilteredList<Task> filteredTasks = new FilteredList<>(ddb.getTasks());
        Task toAdd = helper.generateFullTask(1);
        ddb.addTask(toAdd);
        
        filteredTasks.setPredicate((new PredicateExpression(
                new OnDateQualifier(LocalDateTime.now(), false, SearchCompletedOption.ALL)))::satisfies);
        assertEquals(filteredTasks.size(), 0);
        
        Task toAddToday = helper.generateTaskWithDates("today", "4 days later");
        ddb.addTask(toAddToday);
        
        Task toAddNoDate = helper.generateTaskWithDates(null, null);
        ddb.addTask(toAddNoDate);
        
        filteredTasks.setPredicate((new PredicateExpression(
                new OnDateQualifier(LocalDateTime.now(), false, SearchCompletedOption.ALL)))::satisfies);
        assertEquals(filteredTasks.size(), 1);
    }
    
    
    
}
```
###### /java/seedu/todo/model/RecurrenceTest.java
``` java
/**
 * Test class for recurrence
 *
 */
public class RecurrenceTest {

    @Rule
    public ExpectedException thrown = ExpectedException.none();
    LocalDateTime ldt = LocalDateTime.now();
    
    @Test
    public void recurrence_init_test() throws IllegalValueException {
        Recurrence r = new Recurrence(Frequency.NONE);
        assertEquals(r.getFreq(), Recurrence.Frequency.NONE);
        
        
    }
    
    @Test
    public void execute_updateTaskDateWeek_successful() throws Exception{
        TestDataHelper helper = new TestDataHelper();
        Task toBeRecur = helper.generateFullTask(0);
        
        toBeRecur.setRecurrence(new Recurrence(Frequency.WEEK));
        LocalDateTime oldOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime oldByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        toBeRecur.getRecurrence().updateTaskDate(toBeRecur);
        
        LocalDateTime newOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime newByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        assertEquals(toBeRecur.getRecurrence().toString(), Frequency.WEEK.toString());
        assertEquals(oldOnDateTime.plusWeeks(1), newOnDateTime);
        assertEquals(oldByDateTime.plusWeeks(1), newByDateTime);
        
    }
    
    @Test
    public void execute_updateTaskDateDay_successful() throws Exception{
        TestDataHelper helper = new TestDataHelper();
        Task toBeRecur = helper.generateFullTask(0);
        
        toBeRecur.setRecurrence(new Recurrence(Frequency.DAY));
        LocalDateTime oldOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime oldByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        toBeRecur.getRecurrence().updateTaskDate(toBeRecur);
        
        LocalDateTime newOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime newByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        assertEquals(toBeRecur.getRecurrence().toString(), Frequency.DAY.toString());
        assertEquals(oldOnDateTime.plusDays(1), newOnDateTime);
        assertEquals(oldByDateTime.plusDays(1), newByDateTime);
        
    }
    
    @Test
    public void execute_updateTaskDateMonth_successful() throws Exception{
        TestDataHelper helper = new TestDataHelper();
        Task toBeRecur = helper.generateFullTask(0);
        
        toBeRecur.setRecurrence(new Recurrence(Frequency.MONTH));
        LocalDateTime oldOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime oldByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        toBeRecur.getRecurrence().updateTaskDate(toBeRecur);
        
        LocalDateTime newOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime newByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        assertEquals(toBeRecur.getRecurrence().toString(), Frequency.MONTH.toString());
        assertEquals(oldOnDateTime.plusMonths(1), newOnDateTime);
        assertEquals(oldByDateTime.plusMonths(1), newByDateTime);
        
    }
    
    @Test
    public void execute_updateTaskDateYear_successful() throws Exception{
        TestDataHelper helper = new TestDataHelper();
        Task toBeRecur = helper.generateFullTask(0);
        
        toBeRecur.setRecurrence(new Recurrence(Frequency.YEAR));
        LocalDateTime oldOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime oldByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        toBeRecur.getRecurrence().updateTaskDate(toBeRecur);
        
        LocalDateTime newOnDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getOnDate().getDate(), toBeRecur.getOnDate().getTime());
        
        LocalDateTime newByDateTime = DateTimeUtil.combineLocalDateAndTime(
                toBeRecur.getByDate().getDate(), toBeRecur.getByDate().getTime());
        
        assertEquals(toBeRecur.getRecurrence().toString(), Frequency.YEAR.toString());
        assertEquals(oldOnDateTime.plusYears(1), newOnDateTime);
        assertEquals(oldByDateTime.plusYears(1), newByDateTime);
        
    }
     
    
}
```
###### /java/seedu/todo/model/TaskDateTest.java
``` java
/**
 * Test class for taskdate
 */
public class TaskDateTest {
    
    @Rule
    public ExpectedException thrown = ExpectedException.none();
    
    @Test
    public void taskDateCompareToTest() throws IllegalValueException {
        TaskDate today = new TaskDate("today", TaskDate.TASK_DATE_ON);
        TaskDate tmr = new TaskDate("tomorrow", TaskDate.TASK_DATE_ON);
        TaskDate yest = new TaskDate("yesterday", TaskDate.TASK_DATE_ON);
    
        TaskDate null1 = new TaskDate("", TaskDate.TASK_DATE_ON);
        TaskDate null2 = new TaskDate("", TaskDate.TASK_DATE_ON);
        
        assertEquals(0, null1.compareTo(null2));
        assertEquals(1, null1.compareTo(today));
        assertEquals(-1, today.compareTo(null1));
        assertEquals(0, today.compareTo(today));
        assertEquals(-1, today.compareTo(tmr));
        assertEquals(1, today.compareTo(yest));
    }
    
    
}
```
###### /java/seedu/todo/storage/StorageManagerTest.java
``` java
    @Test
    public void toDoListReadSave() throws Exception {
        DoDoBird original = new TypicalTestTasks().getTypicalToDoList();
        storageManager.saveToDoList(original);
        ReadOnlyToDoList retrieved = storageManager.readToDoList().get();
        
        DoDoBird retrievedDdb = new DoDoBird();
        
        for (int i = retrieved.getTaskList().size() - 1; i >= 0; i--) {
            retrievedDdb.addTask(new Task(retrieved.getTaskList().get(i)));
        }
        
        assertEquals(original, retrievedDdb);
        //More extensive testing of ToDoList saving/reading is done in XmlToDoListStorageTest
    }
```
###### /java/seedu/todo/testutil/TaskBuilder.java
``` java
/**
 * Factory class for building TestTask
 */
public class TaskBuilder {

    private TestTask task;

    public TaskBuilder() {
        this.task = new TestTask();
    }

    public TaskBuilder withName(String name) throws IllegalValueException {
        this.task.setName(new Name(name));
        return this;
    }
    
    public TaskBuilder withCompletion(boolean completed) {
        this.task.setCompletion(new Completion(completed));
        return this;
    }
    
    public TaskBuilder withRecurrence(Frequency freq) throws IllegalValueException{
        this.task.setRecurrence(new Recurrence(freq));
        return this;
    }

    public TaskBuilder withTags(String ... tags) throws IllegalValueException {
        for (String tag: tags) {
            task.getTags().add(new Tag(tag));
        }
        return this;
    }

    public TaskBuilder withDetail(String detail) throws IllegalValueException {
        this.task.setDetail(new Detail(detail));
        return this;
    }

    public TaskBuilder withOnDate(String dateString) throws IllegalValueException {
        this.task.setOnDate(new TaskDate(dateString, TaskDate.TASK_DATE_ON));
        return this;
    }

    public TaskBuilder withByDate(String dateString) throws IllegalValueException {
        this.task.setByDate(new TaskDate(dateString, TaskDate.TASK_DATE_BY));
        return this;
    }

    public TaskBuilder withPriority(String priority) throws IllegalValueException {
        this.task.setPriority(new Priority(priority));
        return this;
    }
    
    public TestTask build() {
        return this.task;
    }

}
```
###### /java/seedu/todo/testutil/TestUtil.java
``` java
    private static Task[] getSampleTaskData() {
        try {
            return new Task[]{
                new Task(new Name("Ali Muster"), new Detail("9482424"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY),
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("Boris Mueller"), new Detail("87249245"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY), 
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("Carl Kurz"), new Detail("95352563"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY), 
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("Daniel Meier"), 
                        new Detail("87652533"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY),
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("Elle Meyer"), new Detail("9482224"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY), 
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("Fiona Kunz"), new Detail("9482427"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY), 
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("George Best"), new Detail("9482442"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY), 
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("Hoon Meier"), new Detail("8482424"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY), 
                        new Priority("low"),
                        new Recurrence(Frequency.NONE)),
                new Task(new Name("Ida Mueller"), new Detail("8482131"), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_ON), 
                        new TaskDate("12/12/1234", TaskDate.TASK_DATE_BY), 
                        new Priority("low"),
                        new Recurrence(Frequency.NONE))
            };
        } catch (IllegalValueException e) {
            assert false;
            //not possible
            return null;
        }
    }
```
###### /java/seedu/todo/testutil/TestUtil.java
``` java
    /**
     * Prepends tasks to the array of tasks.
     * @param tasks A array of tasks.
     * @param tasksToAdd The tasks that are to be appended behind the original array.
     * @return The modified array of tasks.
     */
    public static TestTask[] addTasksToList(final TestTask[] tasks, TestTask... tasksToAdd) {
        List<TestTask> listOfTasks = asList(tasks);
        for (TestTask t : tasksToAdd) {
            listOfTasks.add(0, t); 
        }
        return listOfTasks.toArray(new TestTask[listOfTasks.size()]);
    }
```
###### /java/seedu/todo/testutil/TypicalTestTasks.java
``` java
/**
 * class to generate typical tasks
 */
public class TypicalTestTasks {

    public static TestTask buyGroceries, buyMilk, buyRice, buyChilli, buyNoodles, buyCheese;

    public TypicalTestTasks() {
        try {
            buyGroceries =  new TaskBuilder().withName("Buy Groceries").withByDate("12/12/2016")
                    .withOnDate("12/10/2016").withDetail("fish").withCompletion(true)
                    .withRecurrence(Frequency.NONE).withTags("urgent").withPriority("mid").build();
            
            buyMilk =  new TaskBuilder().withName("Buy Milk").withByDate("12/12/2016")
                    .withOnDate("20/10/2016").withDetail("Marigold").withCompletion(true)
                    .withRecurrence(Frequency.NONE).withTags("urgent").withPriority("mid").build();
            
            buyRice =  new TaskBuilder().withName("Buy Rice").withByDate("12/12/2016")
                    .withOnDate("30/10/2016").withDetail("Thai Rice").withCompletion(true).
                    withRecurrence(Frequency.NONE).withTags("urgent").withPriority("mid").build();
            
            buyChilli =  new TaskBuilder().withName("Buy Chilli").withByDate("12/12/2016")
                    .withOnDate("12/11/2016").withDetail("Red").withCompletion(true)
                    .withRecurrence(Frequency.NONE).withTags("urgent").withPriority("mid").build();
            
            buyNoodles = new TaskBuilder().withName("Buy Noodles").withByDate("12/12/2016")
                    .withOnDate("12/11/2016").withDetail("Red").withCompletion(true)
                    .withRecurrence(Frequency.NONE).withTags("urgent").withPriority("mid").build();
            
            buyCheese = new TaskBuilder().withName("Buy Cheese").withByDate("12/12/2016")
                    .withOnDate("12/11/2016").withDetail("Red").withCompletion(true)
                    .withRecurrence(Frequency.NONE).withTags("urgent").withPriority("mid").build();
            
        } catch (IllegalValueException e) {
            e.printStackTrace();
            assert false : "not possible";
        }
    }

    public static void loadToDoListWithSampleData(DoDoBird ab) {

        try {
            ab.addTask(new Task(buyGroceries));
            ab.addTask(new Task(buyChilli));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            assert false : "not possible";
        }
    }

    public TestTask[] getTypicalTasks() {
        return new TestTask[]{buyGroceries, buyChilli, buyMilk, buyCheese};
    }
    
    public TestTask[] getTypicalTasksReverse() {
        return new TestTask[]{buyCheese, buyMilk, buyChilli, buyGroceries};
    }
    
    public TestTask[] getEmptyTaskList() {
        return new TestTask[]{};
    }

    public DoDoBird getTypicalToDoList(){
        DoDoBird ab = new DoDoBird();
        loadToDoListWithSampleData(ab);
        return ab;
    }
}
```
