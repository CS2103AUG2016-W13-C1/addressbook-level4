# A0093896H
###### /java/seedu/todo/commons/core/Config.java
``` java
    public static final String DEFAULT_CONFIG_FILE = "defaultConfig.json";
```
###### /java/seedu/todo/commons/core/Config.java
``` java
    public void resetConfig(Config initializedConfig) throws IOException {
        ConfigUtil.saveConfig(initializedConfig, USER_CONFIG_FILE);
        
        this.setAppTitle(initializedConfig.getAppTitle());
        this.setLogLevel(initializedConfig.getLogLevel());
        this.setToDoListFilePath(initializedConfig.getToDoListFilePath());
        this.setToDoListName(initializedConfig.getToDoListName());
        this.setUserPrefsFilePath(initializedConfig.getUserPrefsFilePath());
    }
```
###### /java/seedu/todo/commons/events/storage/SaveLocationChangedEvent.java
``` java
/** Indicates the save location for the data has changed*/
public class SaveLocationChangedEvent extends BaseEvent {
   
    public final String location;

    public SaveLocationChangedEvent(String location){
        this.location = location;
    }

    @Override
    public String toString() {
        return this.location;
    }
}
```
###### /java/seedu/todo/commons/util/DateTimeUtil.java
``` java
/**
 * Helper functions for anything with regards to date and time.
 */
public class DateTimeUtil {


    public static final int DEFAULT_ON_HOUR = 0;
    public static final int DEFAULT_ON_MINUTE = 0;        
    public static final int DEFAULT_BY_HOUR = 23;
    public static final int DEFAULT_BY_MINUTE = 59;
    
    /**
     * Checks whether a dateTimeString is empty
     */
    public static boolean isEmptyDateTimeString(String dateTimeString) {
        return (dateTimeString == null || dateTimeString.equals("") || dateTimeString.equals(" "));
    }

    /**
     * Attempts to parse a String into LocalDateTime.
     * 
     * If the String does not contains date information, the default date used is the current date.
     * 
     * If the String does not contains time information, the default time used is the 0000hrs if
     * it is an onDate and 2359 if it is a byDate.
     * 
     */
    public static LocalDateTime parseDateTimeString(String dateTimeString, String onOrBy) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);

        if (groups.size() != 0) {
            Map<String, List<ParseLocation>> m = groups.get(0).getParseLocations();
            Date date = groups.get(0).getDates().get(0);
            
            Calendar c = Calendar.getInstance();
            c.setTime(date);
            
            LocalDateTime ldt;
            if (!m.keySet().contains("date")) {
                LocalDateTime now = LocalDateTime.now();
                ldt = LocalDateTime.of(now.getYear(), now.getMonth(), now.getDayOfMonth(), 
                        c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE));
            } else {
                if (!m.keySet().contains("explicit_time")) {
                    if (onOrBy.equals(TaskDate.TASK_DATE_BY)) {
                        ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                                c.get(Calendar.DATE), DEFAULT_BY_HOUR, DEFAULT_BY_MINUTE);
                    } else {
                        ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                                c.get(Calendar.DATE), DEFAULT_ON_HOUR, DEFAULT_ON_MINUTE);
                    }
                } else {
                    ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                            c.get(Calendar.DATE), c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE));
                }
            }
            return ldt;
        }
        
        return null;
    }

    
    /**
     * Checks whether date information is able to be parsed out 
     * from a String
     */
    public static boolean containsDateField(String dateTimeString) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);
        
        if (groups.size() == 0) {
            return false;
        } else {
            DateGroup group = groups.get(0);
            Map<String, List<ParseLocation>> m = group.getParseLocations();
            return m.keySet().contains("date");
        }
    }
    
    /**
     * Checks whether time information is able to be parsed out  from a String
     */
    public static boolean containsTimeField(String dateTimeString) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);
        
        if (groups.size() == 0) {
            return false;
        } else {
            DateGroup group = groups.get(0);
            Map<String, List<ParseLocation>> m = group.getParseLocations();
            return m.keySet().contains("explicit_time");
        }
    }
```
###### /java/seedu/todo/commons/util/DateTimeUtil.java
``` java
    /**
     * Combines LocalDate and LocalTime to LocalDateTime with default time being 2359
     */
    public static LocalDateTime combineLocalDateAndTime(LocalDate date, LocalTime time) {
        assert date != null;
        if (time == null) {
            return LocalDateTime.of(date.getYear(), date.getMonth(), date.getDayOfMonth(), 23, 59);
        } else {
            return LocalDateTime.of(date, time);
        }
    }
      
    public static String prettyPrintDate(LocalDate date) {
        return date.format(DateTimeFormatter.ofPattern("dd MMM yyyy"));
    }

    public static String prettyPrintTime(LocalTime time) {
        return time.format(DateTimeFormatter.ofPattern("hh:mm a"));
    }

}
```
###### /java/seedu/todo/logic/commands/AddCommand.java
``` java
/**
 * Adds a task into DoDo-Bird
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the to do list.\n"
            + "Parameters: TASKNAME on STARTDATE by ENDDATE priority PRIORITY every RECURRENCE; DETAILS...\n"
            + "Example: " + COMMAND_WORD
            + " get groceries on 10/10/2016 by 11/10/2016 ; bread, fruits, cinnamon powder, red pepper";

    public static final String MESSAGE_SUCCESS = "New task added!\n%1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the to do list";
    
    public static final String MESSAGE_INVALID_DATE_RANGE = "You entered a starting date later "
            + "than the ending date.\n"
            + "Please ensure that the starting date is earlier than the ending date.";
    
    private final Task toAdd;
    
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String detail, String onDateString, 
                      String byDateString, String priority, String freq)
                      throws IllegalValueException {
        
        if (priority == null) {
            priority = Priority.LOW;
        }
        
        if (freq == null) {
            freq = Frequency.NONE.name();
        }
        
        this.toAdd = new Task(
                new Name(name),
                new Detail(detail),
                new TaskDate(onDateString, TaskDate.TASK_DATE_ON),
                constructByDate(onDateString, byDateString),
                new Priority(priority),
                new Recurrence(Frequency.valueOf(freq.toUpperCase().trim()))
        );
    }
    
    
    /**
     * Executes the add command. The new task is added to the top of the list.
     * 
     * Informs the user if duplicated task is added.
     * Refer to {@link seedu.todo.model.task.ReadOnlyTask#isSameStateAs(ReadOnlyTask)} 
     * for equivalence testing.
     */
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            model.updateFilteredListToShowAllNotCompleted();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }
    
    
    /**
     * Constructs the byDate based on the onDate.
     * Validates that the byDate cannot be earlier than on date.
     */
    private TaskDate constructByDate(String onDateString, String byDateString) throws IllegalValueException {
        TaskDate onDate = new TaskDate(onDateString, TaskDate.TASK_DATE_ON);
        TaskDate byDate = new TaskDate(byDateString, TaskDate.TASK_DATE_BY);
        
        if (byDate.getDate() != null && !DateTimeUtil.containsDateField(byDateString)) {
            byDate.setDate(LocalDate.of(onDate.getDate().getYear(), 
                    onDate.getDate().getMonth(), onDate.getDate().getDayOfMonth()));
        }
        
        if (!DateTimeUtil.beforeOther(onDate, byDate)) {
            throw new IllegalValueException(MESSAGE_INVALID_DATE_RANGE);
        }
        
        return byDate;
    }

}
```
###### /java/seedu/todo/logic/commands/DeleteCommand.java
``` java
    public static final String MESSAGE_DELETE_TASK_SUCCESS = "Deleted Task at Index: %1$d\nName : %2$s";
```
###### /java/seedu/todo/logic/commands/DeleteCommand.java
``` java
    /**
     * Executes the delete command.
     * 
     * Will inform the user if an invalid index is used or the task cannot be found. 
     */
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.deleteTask(taskToDelete);
            model.refreshCurrentFilteredTaskList();
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_TASK_NOT_FOUND);
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, targetIndex, taskToDelete));
    }

}
```
###### /java/seedu/todo/logic/commands/ResetCommand.java
``` java
/**
 * Reset Config to default
 */
public class ResetCommand extends Command {

    public static final String COMMAND_WORD = "reset";

    public static final String MESSAGE_SUCCESS = "Reset User Config !";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reset the user config to default"
            + "Example: " + COMMAND_WORD;
    
    public static final String MESSAGE_SAVE_ERROR = "Unable to save config to new location.";
    
    /**
     * Executes the Reset Command.
     * 
     * Informs the user if unable to save config at default location.
     */
    @Override
    public CommandResult execute() {
        
        String configFilePathUsed = Config.DEFAULT_CONFIG_FILE;
        
        Config initializedConfig;
        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(configFilePathUsed);
            initializedConfig = configOptional.orElse(new Config());
        } catch (DataConversionException e) {
            initializedConfig = new Config();
        } 
        
        try {
            config.resetConfig(initializedConfig);
            storage.updateToDoListFilePath(config.getToDoListFilePath(), model.getToDoList());
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_SAVE_ERROR);
        }
          
    }
        
   
}
```
###### /java/seedu/todo/logic/commands/StoreCommand.java
``` java
/**
 * Change data storage location
 */
public class StoreCommand extends Command {

    public static final String COMMAND_WORD = "store";

    public static final String MESSAGE_SUCCESS = "Change storage location! New location is at: %1$s";
    
    public static final String MESSAGE_SAVE_ERROR = "Unable to save to new location.";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Changes the storage location to the location specified by the user. "
            + "Parameters: NEW_STORAGE_LOCATION\n"
            + "Example: " + COMMAND_WORD + "data/dodobird.xml";

    private final String location;
    
    public StoreCommand(String newLocation) {
        this.location = newLocation;
    }
    
    /**
     * Executes the store command.
     * 
     * Checks if the newly specified location is valid and save to the location if so.
     * If the specified location is not valid, reset the location to default location. 
     */
    @Override
    public CommandResult execute() {
        String defaultLocation = config.getToDoListFilePath();
        String tempLocation = this.location + "/" + config.getToDoListName() + ".xml";
        
        if (FileUtil.isFilenameValid(tempLocation)) {
            try {
                config.updateToDoListFilePath(tempLocation);
                storage.updateToDoListFilePath(tempLocation, model.getToDoList());
                return new CommandResult(String.format(MESSAGE_SUCCESS, tempLocation));
                
            } catch (IOException e){
                config.setToDoListFilePath(defaultLocation);
                storage.setToDoListFilePath(defaultLocation);
                return new CommandResult(MESSAGE_SAVE_ERROR);
            }
        } else {
            return new CommandResult(MESSAGE_SAVE_ERROR);
        }
          
    }
        
   
}
```
###### /java/seedu/todo/logic/commands/UnmarkCommand.java
``` java
/**
 * Unmark a task identified using it's last displayed index from the to do list.
 */
public class UnmarkCommand extends Command {
    
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unmarks the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Unmark Task at Index: %1$d\n%2$s";
    public static final String MESSAGE_RECURRING = "You cannot unmark a recurring task!";

    public final int targetIndex;

    public UnmarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    /**
     * Executes the unmark Command
     * 
     * Will return a message to inform the user if an invalid target index is used 
     * or the task specified cannot be found,
     */
    @Override
    public CommandResult execute() {
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
        if (taskToMark.isRecurring()) {
            return new CommandResult(MESSAGE_RECURRING);
        }
        try {
            Task newTask = new Task(taskToMark);
            newTask.setCompletion(new Completion(false));
            model.updateTask(taskToMark, newTask);
            
            model.refreshCurrentFilteredTaskList();
            model.updateTodayListToShowAll();
            model.updateWeekListToShowAll();
            
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_TASK_NOT_FOUND);
        } 
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, targetIndex, taskToMark));
    }
}
```
###### /java/seedu/todo/logic/commands/UpdateCommand.java
``` java
/**
 * Updates a task identified using it's last displayed index from the to do list.
 */
public class UpdateCommand extends Command {

    public static final String COMMAND_WORD = "update";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Update the task identified by the index number used in the last task listing. \n"
            + "Prefix a - sign in front of optional fields you wished to remove.\n"
            + "Parameters: ID [NEW_NAME] [[-]on DATE [tTime]] [[-]by DATE [tTime]] [[-]; a line of new details]\n"
            + "Example: " + COMMAND_WORD + " 2 on 14/10/2017 by 18/10/2017 ";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Update Task at Index: %1$d\n%2$s";
    public static final String MESSAGE_INVALID_DATE_RANGE = "You entered a starting date later than the ending date.\n"
            + "Please ensure that the starting date is earlier than the ending date.";
    
    private final int targetIndex;
    
    private final String name;
    private final String detail;
    private final String onDateTime;
    private final String byDateTime;
    private final String priority;
    private final String recurrence;
    
    /**
     * Takes in the raw value for each data field. Does not provide validation check 
     * at this juncture.
     * 
     * @param targetIndex
     * @param name
     * @param onDateTime
     * @param byDateTime
     * @param detail
     * @param priority
     * @param recurrence
     */
    public UpdateCommand(int targetIndex, String name, String onDateTime, 
            String byDateTime, String detail, String priority, String recurrence) {
        this.targetIndex = targetIndex;
        this.name = name;
        this.detail = detail;
        this.onDateTime = onDateTime;
        this.byDateTime = byDateTime;
        this.priority = priority;
        this.recurrence = recurrence;
    }
    
    /**
     * Executes the update command.
     * Constructs a new task to be the replicated by the old task in model.
     * 
     * TODO: Add validation check for on date before by date
     */
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(targetIndex - 1);
        
        try {            
            Name newName = this.makeNewName(taskToUpdate);
            Detail newDetail = this.makeNewDetail(taskToUpdate);
            TaskDate newByDate = this.makeNewByDate(taskToUpdate);
            TaskDate newOnDate = this.makeNewOnDate(taskToUpdate);
            Priority newPriority = this.makeNewPriority(taskToUpdate);
            Recurrence newRecurrence = this.makeNewRecurrence(taskToUpdate);
            
            if (!DateTimeUtil.beforeOther(newOnDate, newByDate)) {
                throw new IllegalValueException(MESSAGE_INVALID_DATE_RANGE);
            }
            
            Task newTask = new Task(newName, newDetail, taskToUpdate.getCompletion(), 
                    newOnDate, newByDate, newPriority, newRecurrence, taskToUpdate.getTags());
            
            model.updateTask(taskToUpdate, newTask);
            
            model.refreshCurrentFilteredTaskList();
            model.updateTodayListToShowAll(); 
            model.updateWeekListToShowAll();
            return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, targetIndex, newTask));
            
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_TASK_NOT_FOUND);
        
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage());
        }
        
    }
    
    /**
     * Construct a new Name based on user input
     */
    private Name makeNewName(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        return this.name.equals("") ? taskToUpdate.getName() : new Name(this.name);
    }
    
    /**
     * Construct a new Detail based on user input
     */
    private Detail makeNewDetail(ReadOnlyTask taskToUpdate) {
        Detail newDetail;
        if (this.detail == null) {
            newDetail = taskToUpdate.getDetail();
        } else {
            newDetail = this.detail.trim().equals("-") 
                    ?  new Detail(null) 
                    : new Detail(this.detail);
        }
        return newDetail;
    }
    
    /**
     * Construct a new ByDate based on user input
     */
    private TaskDate makeNewByDate(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        TaskDate newByDate;
        if (this.byDateTime == null) {
            newByDate = taskToUpdate.getByDate();
        } else {
            newByDate = this.byDateTime.trim().equals("-") 
                    ?  new TaskDate("", TaskDate.TASK_DATE_BY) 
                    : new TaskDate(this.byDateTime, TaskDate.TASK_DATE_BY);
        }
        return newByDate;
    }
    
    /**
     * Construct a new OnDate based on user input
     */
    private TaskDate makeNewOnDate(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        TaskDate newOnDate;
        if (this.onDateTime == null) {
            newOnDate = taskToUpdate.getOnDate();
        } else {
            newOnDate = this.onDateTime.trim().equals("-") 
                    ?  new TaskDate("", TaskDate.TASK_DATE_ON) 
                    : new TaskDate(this.onDateTime, TaskDate.TASK_DATE_ON);
        }
        return newOnDate;
    }
    
    /**
     * Construct a new Recurrence based on user input
     */
    private Recurrence makeNewRecurrence(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        Recurrence newRecurrence;
        if (this.recurrence == null) {
            newRecurrence = taskToUpdate.getRecurrence();
        } else {
            newRecurrence = this.recurrence.trim().equals("-") 
                    ?  new Recurrence(Frequency.NONE) 
                    : new Recurrence(Frequency.valueOf(this.recurrence.toUpperCase().trim()));
        }
        return newRecurrence;
    } 
    
```
###### /java/seedu/todo/logic/parser/ParserFormats.java
``` java
    public static final Pattern ADD_TASK_ARGS_FORMAT = Pattern
            .compile("(?<name>[^/]+?) "
                      + "?((^| )(on (?<onDateTime>[^;]+?)?"
                      + "|by (?<byDateTime>[^;]+?)"
                      + "|priority (?<priority>[^;]+?)"
                      + "|every (?<rec>[^;]+?)))*?"
                      + "(?: ?;(?<detail>.+))?$", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern UPDATE_TASK_ARGS_FORMAT = Pattern
            .compile("(?<name>[^/]*?)? "
                      + "?((^| )(on (?<onDateTime>[^;]+?)?"
                      + "|by (?<byDateTime>[^;]+?)"
                      + "|priority (?<priority>[^;]+?)"
                      + "|every (?<rec>[^;]+?)))*?"
                      + "(?: ?;(?<detail>.+))?$", Pattern.CASE_INSENSITIVE);
    
    
```
###### /java/seedu/todo/logic/parser/ParserFormats.java
``` java
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_ON = Pattern
            .compile("on (?<onDateTime>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_BEFORE = Pattern
            .compile("before (?<beforeDateTime>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_AFTER = Pattern
            .compile("after (?<afterDateTime>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_FT = Pattern
            .compile("from (?<fromDateTime>.+?) to (?<tillDateTime>.+?)(?<comOpt> done|all|undone)?", 
                    Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_TAG = Pattern
            .compile("tag (?<tags>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_KEYWORDS_ARGS_FORMAT = Pattern
            .compile("(?<keywords>.+?)(?<comOpt> done|all|undone)?"); 
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_FLOATING = Pattern
            .compile("floating(?<comOpt> done| all| git sundone)?", Pattern.CASE_INSENSITIVE); 
    
```
###### /java/seedu/todo/logic/parser/ToDoListParser.java
``` java
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = ParserFormats.BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");

        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case MarkCommand.COMMAND_WORD:
            return prepareMark(arguments);

        case SearchCommand.COMMAND_WORD:
            return prepareSearch(arguments);

        case TagCommand.COMMAND_WORD:
            return prepareTag(arguments);

        case UntagCommand.COMMAND_WORD:
            return prepareUntag(arguments);

        case UnmarkCommand.COMMAND_WORD:
            return prepareUnmark(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();

        case UpdateCommand.COMMAND_WORD:
            return prepareUpdate(arguments);
            
        case StoreCommand.COMMAND_WORD:
            return prepareStore(arguments);
            
        case ResetCommand.COMMAND_WORD:
            return new ResetCommand();

        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
```
###### /java/seedu/todo/logic/parser/ToDoListParser.java
``` java
    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareAdd(String args) {
        
        String tempArgs = args.trim(); 
        
        if (tempArgs.isEmpty()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    AddCommand.MESSAGE_USAGE));
        }

        Matcher matcher;
        matcher = ParserFormats.ADD_TASK_ARGS_FORMAT.matcher(tempArgs.trim());
        
        if (matcher.matches()) {
            try {
                return new AddCommand(matchNameResult(matcher).trim(),
                        matchDetailResult(matcher), 
                        matchOnDateTimeResult(matcher), 
                        matchByDateTimeResult(matcher), 
                        matchPriorityResult(matcher), 
                        matchRecurrenceResult(matcher));
                
            } catch (IllegalValueException ive) {
                return new IncorrectCommand(ive.getMessage());
            } catch (IllegalArgumentException iae) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT,
                        AddCommand.MESSAGE_USAGE));
            }
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    UpdateCommand.MESSAGE_USAGE));
        }  
    }
    
    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());
    }
```
###### /java/seedu/todo/logic/parser/ToDoListParser.java
``` java
    /**
     * Parses arguments in the context of the unmark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUnmark(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    UnmarkCommand.MESSAGE_USAGE));
        }

        return new UnmarkCommand(index.get());
    }
```
###### /java/seedu/todo/logic/parser/ToDoListParser.java
``` java
    /**
     * Parses arguments in the context of the update task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUpdate(String args) {
        
        String tempArgs = args.trim(); 
        
        if (tempArgs.length() < 1) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    UpdateCommand.MESSAGE_USAGE));
        }
        String indexString = tempArgs.split(" ")[0];

        Optional<Integer> index = parseIndex(indexString);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    UpdateCommand.MESSAGE_USAGE));
        }

        tempArgs = tempArgs.substring(indexString.length()).trim();

        Matcher matcher;
        matcher = ParserFormats.UPDATE_TASK_ARGS_FORMAT.matcher(tempArgs.trim());
        if (matcher.matches()) {
            return new UpdateCommand(index.get(), 
                    matchNameResult(matcher).trim(), 
                    matchOnDateTimeResult(matcher), 
                    matchByDateTimeResult(matcher), 
                    matchDetailResult(matcher), 
                    matchPriorityResult(matcher), 
                    matchRecurrenceResult(matcher));
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, 
                    UpdateCommand.MESSAGE_USAGE));
        }  
        

    }
```
###### /java/seedu/todo/logic/parser/ToDoListParser.java
``` java
    /**
     * Parses arguments in the context of the store command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareStore(String args) {
        args = args.trim();
        return new StoreCommand(args);
    }

}
```
###### /java/seedu/todo/model/DoDoBird.java
``` java
    private final Stack<UniqueTaskList> tasksHistory;
    private final Stack<UniqueTagList> tagsHistory;
```
###### /java/seedu/todo/model/DoDoBird.java
``` java
    /**
     * Tasks and Tags are copied into this ToDoList
     */
    public DoDoBird(UniqueTaskList tasks, UniqueTagList tags) {
        tasksHistory = new Stack<>();
        tagsHistory = new Stack<>();
        resetData(tasks.getInternalList(), tags.getInternalList());
    }
```
###### /java/seedu/todo/model/DoDoBird.java
``` java
    @Override
    public UniqueTaskList getUniqueTaskList() {
        return this.tasksHistory.peek();
    }

```
###### /java/seedu/todo/model/DoDoBird.java
``` java

    public ObservableList<Task> getTasks() {
        return tasksHistory.peek().getInternalList();
    }
    
    public ObservableList<Tag> getTags() {
        return tagsHistory.peek().getInternalList();
    }
    
```
###### /java/seedu/todo/model/DoDoBird.java
``` java
    public void setTasks(List<Task> tasks) {
        if (this.tasksHistory.isEmpty()) {
            Collections.reverse(tasks);
            UniqueTaskList topList = this.copyTaskList(tasks);
            this.tasksHistory.push(topList);
        } else {
            this.updateTaskHistoryStack();
            this.getTasks().setAll(tasks);
        }
    }
    
```
###### /java/seedu/todo/model/DoDoBird.java
``` java
    /**
     * Adds a task to the to do list.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws DuplicateTaskException {
        updateTaskHistoryStack();
        updateTagHistoryStack();

        try {
            this.getUniqueTaskList().add(p);
        } catch (DuplicateTaskException e) {
            undo();
            throw e;
        }
        
    }
    
    /**
     * Deletes a task to the to do list.
     * Also checks the deleted task's tags and updates {@link #tags} to remove or decrease
     * the tag count.
     *
     * @throws UniqueTaskList.TaskNotFoundException if the task cannot be found
     */
    public void deleteTask(ReadOnlyTask key) throws TaskNotFoundException {
        updateTaskHistoryStack();
        updateTagHistoryStack();
        
        try {
            this.getUniqueTaskList().remove(key);
        } catch (TaskNotFoundException e) {
            undo();
            throw e;
        }
        updateTagTopList();

    }
    
    /**
     * Updates a task to the to do list.
     */
    public void updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) {
        updateTaskHistoryStack();
        updateTagHistoryStack();
         
        int index = this.getTaskIndex(oldTask);
            
        this.getTasks().get(index).setName(newTask.getName());
        this.getTasks().get(index).setDetail(newTask.getDetail());
        this.getTasks().get(index).setOnDate(newTask.getOnDate());
        this.getTasks().get(index).setByDate(newTask.getByDate());
        this.getTasks().get(index).setCompletion(newTask.getCompletion());
        this.getTasks().get(index).setPriority(newTask.getPriority());
        this.getTasks().get(index).setRecurrence(newTask.getRecurrence());
        
    }
    
```
###### /java/seedu/todo/model/DoDoBird.java
``` java
    /**
     * Updates the dates of a task based on the recurrence frequency.
     */
    public void updateTasksRecurrence() {
        for (Task t : this.getTasks()) {
            if (t.isRecurring()) { 
                LocalDate onDate = t.getOnDate().getDate();
                LocalDate byDate = t.getByDate().getDate();
                if ((onDate != null && onDate.isBefore(LocalDate.now()))
                     || byDate != null && byDate.isBefore(LocalDate.now())) {
                    t.getRecurrence().updateTaskDate(t);
                }
            }
        }
    }
```
###### /java/seedu/todo/model/DoDoBird.java
``` java
    @Override
    public String toString() {
        return tasksHistory.peek().getInternalList().size() + " tasks, " 
                + tagsHistory.peek().getInternalList().size() +  " tags";
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DoDoBird // instanceof handles nulls
                && this.tasksHistory.peek().equals(((DoDoBird) other).tasksHistory.peek())
                && this.tagsHistory.peek().equals(((DoDoBird) other).tagsHistory.peek()));
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasksHistory.peek(), tagsHistory.peek());
    }
    
    /**
     * Updates tasks history
     * Maintains the reference of the top UniqueTaskList
     * Call this method for add, delete, update
     */
    private void updateTaskHistoryStack() {
        UniqueTaskList topList = this.tasksHistory.pop();
        UniqueTaskList oldList = this.copyTaskList(topList.getInternalList());
        this.tasksHistory.push(oldList);
        this.tasksHistory.push(topList);
    }
    
    /**
     * Updates tags history
     * Maintains the reference of the top UniqueTagList
     * Call this method for add, delete, update
     */
    private void updateTagHistoryStack() {
        UniqueTagList topList = this.tagsHistory.pop();
        UniqueTagList oldList = this.copyTagList(topList.getInternalList());
        this.tagsHistory.push(oldList);
        this.tagsHistory.push(topList);
        
    }
    
    private UniqueTaskList copyTaskList(List<Task> old) {
        UniqueTaskList newList = new UniqueTaskList();
                
        for (int i = old.size() - 1; i >= 0; i--) {
            try {
                newList.add(new Task(old.get(i)));
            } catch (UniqueTaskList.DuplicateTaskException e) {}
        }
        return newList;
    }
    
 
    private UniqueTagList copyTagList(Collection<Tag> old) {
        UniqueTagList newList = new UniqueTagList();
        
        for (Tag t : old) {
            try {
                newList.add(t);
            } catch (UniqueTagList.DuplicateTagException e) {}
        }
        return newList;
    }
    
}
```
###### /java/seedu/todo/model/Model.java
``` java
    /** Add the given task */
    void addTask(Task task) throws UniqueTaskList.DuplicateTaskException;
    
    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;

    /** Retrieve the give task. */
    Task getTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;
    
    /** Update the given task */
    void updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) 
            throws UniqueTaskList.TaskNotFoundException;
```
###### /java/seedu/todo/model/Model.java
``` java
    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();
    
```
###### /java/seedu/todo/model/Model.java
``` java
    /** Updates the filter of the filtered task list to show all completed tasks */
    void updateFilteredListToShowAllCompleted();

    /** Updates the filter of the filtered task list to show all not completed tasks */
    void updateFilteredListToShowAllNotCompleted();
    
    /** Updates the filter of the filtered task list to show all floating tasks */
    void updateFilteredListToShowAllFloating(SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListByKeywords(Set<String> keywords, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given tag name*/
    void updateFilteredTaskListByTag(String tagName, SearchCompletedOption option);

    /** Updates the filter of the filtered task list to filter by the given date*/
    void updateFilteredTaskListOnDate(LocalDateTime datetime, boolean hasTimeField, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given before date*/
    void updateFilteredTaskListBeforeDate(LocalDateTime datetime, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given after date*/
    void updateFilteredTaskListAfterDate(LocalDateTime datetime, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given from and till dates*/
    void updateFilteredTaskListFromTillDate(LocalDateTime fromDateTime, LocalDateTime tillDateTime, 
            SearchCompletedOption option);
    
    /** Refresh the current filtered task list*/
    void refreshCurrentFilteredTaskList();

```
###### /java/seedu/todo/model/ModelManager.java
``` java
    @Override
    public void resetData(ReadOnlyToDoList newData) {
        dodobird.resetData(newData);
        indicateToDoListChanged();
    }
```
###### /java/seedu/todo/model/ModelManager.java
``` java
    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        dodobird.addTask(task);
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        dodobird.deleteTask(target);
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized Task getTask(ReadOnlyTask target) {
        return dodobird.getTask(dodobird.getTaskIndex(target));
    }
    
    @Override
    public synchronized void updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) throws TaskNotFoundException {
        dodobird.updateTask(oldTask, newTask);
        indicateToDoListChanged();
    }
    
```
###### /java/seedu/todo/model/ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }
    
```
###### /java/seedu/todo/model/ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true))); //force change
        filteredTasks.setPredicate(null);
    }
    
    @Override
    public void updateFilteredListToShowAllCompleted(){
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true)));
    }
    
    @Override
    public void updateFilteredListToShowAllNotCompleted(){
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(false)));
    }

    @Override
    public void updateFilteredTaskListByKeywords(Set<String> keywords, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new KeywordQualifier(keywords, option)));
    }

    @Override
    public void updateFilteredTaskListByTag(String tagName, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new TagQualifier(tagName, option)));
    }
    
    @Override
    public void updateFilteredTaskListOnDate(LocalDateTime datetime, boolean hasTimeField, 
            SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new OnDateQualifier(datetime, hasTimeField, option)));
    }
    
    @Override
    public void updateFilteredTaskListBeforeDate(LocalDateTime datetime, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new BeforeDateQualifier(datetime, option)));
    }

    @Override
    public void updateFilteredTaskListAfterDate(LocalDateTime datetime, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new AfterDateQualifier(datetime, option)));
    }
    
    @Override
    public void updateFilteredTaskListFromTillDate(LocalDateTime fromDateTime, LocalDateTime tillDateTime, 
            SearchCompletedOption option){
        updateFilteredTaskList(new PredicateExpression(new FromTillDateQualifier(fromDateTime, tillDateTime, option)));
    }
    
    @Override
    public void updateFilteredListToShowAllFloating(SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new FloatingQualifier(option)));
    }

```
###### /java/seedu/todo/model/ModelManager.java
``` java
    /**
     * Use this method to refresh the current filtered tasks list.
     * 
     * This method is applicable to commands that updates the tasks in the filtered task list
     * Because the filtered task list have the same task, the UI will not automatically update
     * Therefore need to force the update using this method.
     */
    @Override
    public void refreshCurrentFilteredTaskList() {
        PredicateExpression current = pe;
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true))); // force change
        updateFilteredTaskList(current);
    }
    
    private void updateFilteredTaskList(PredicateExpression expression) {
        filteredTasks.setPredicate(expression::satisfies);
        pe = expression;
    }
```
###### /java/seedu/todo/model/qualifiers/AfterDateQualifier.java
``` java
/**
 * A qualifier that filters tasks if they are to be done after
 * a certain datetime
 */
public class AfterDateQualifier implements Qualifier {
  
    private LocalDateTime datetime;
    private SearchCompletedOption option;
    
    public AfterDateQualifier(LocalDateTime datetime, SearchCompletedOption option) {
        this.datetime = datetime;
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate onDate = task.getOnDate().getDate(); 
        LocalTime onTime = task.getOnDate().getTime();
        
        LocalDate byDate = task.getByDate().getDate(); 
        LocalTime byTime = task.getByDate().getTime();
        
        boolean onAfter = false;
        boolean byAfter = false;
        
        if (onDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(onDate, onTime);
            onAfter = onDateTime.isAfter(datetime);
        }
        
        if (byDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(byDate, byTime);
            byAfter = onDateTime.isAfter(datetime);
        }
        
        boolean taskIsAfter = onAfter || byAfter; //true if either the starting date or ending is after
        
        if (option == SearchCompletedOption.ALL) {
            return taskIsAfter;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsAfter && task.getCompletion().isCompleted();
        } else {
            return taskIsAfter && !task.getCompletion().isCompleted();
        }
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### /java/seedu/todo/model/qualifiers/BeforeDateQualifier.java
``` java
/**
 * A qualifier that filters tasks if they are to be done before
 * a certain datetime
 */
public class BeforeDateQualifier implements Qualifier {
   
    private LocalDateTime datetime;
    private SearchCompletedOption option;
    
    public BeforeDateQualifier(LocalDateTime datetime, SearchCompletedOption option) {
        this.datetime = datetime;
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate onDate = task.getOnDate().getDate(); 
        LocalTime onTime = task.getOnDate().getTime();
        
        LocalDate byDate = task.getByDate().getDate(); 
        LocalTime byTime = task.getByDate().getTime();
        
        boolean onBefore = false;
        boolean byBefore = false;
        
        if (onDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(onDate, onTime);
            onBefore = onDateTime.isBefore(datetime);
        }
        
        if (byDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(byDate, byTime);
            byBefore = onDateTime.isBefore(datetime);
        }
        
        boolean taskIsBefore = onBefore || byBefore; //true if either the starting date or ending is after
        
        if (option == SearchCompletedOption.ALL) {
            return taskIsBefore;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsBefore && task.getCompletion().isCompleted();
        } else {
            return taskIsBefore && !task.getCompletion().isCompleted();
        }
            
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### /java/seedu/todo/model/qualifiers/CompletedQualifier.java
``` java
/**
 * A qualifier that filter tasks depending on whether the task
 * is completed or not.
 */
public class CompletedQualifier implements Qualifier {
    
    private boolean wantsDone;
    
    public CompletedQualifier(boolean wantsDone){
        this.wantsDone = wantsDone;
    }
    
    @Override
    public boolean run(ReadOnlyTask task) {
        return this.wantsDone ? task.getCompletion().isCompleted() : !task.getCompletion().isCompleted();
    }

    @Override
    public String toString() {
        return this.wantsDone ? "done" : "not done";
    }
}
```
###### /java/seedu/todo/model/qualifiers/FloatingQualifier.java
``` java
/**
 * A qualifier that filter floating tasks.
 */
public class FloatingQualifier implements Qualifier {
    
    private SearchCompletedOption option;
    
    public FloatingQualifier(SearchCompletedOption option) {
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate onDate = task.getOnDate().getDate(); 
        LocalDate byDate = task.getByDate().getDate(); 
        
        boolean isFloating = onDate == null && byDate == null;
     
        if (option == SearchCompletedOption.ALL) {
            return isFloating;
        } else if (option == SearchCompletedOption.DONE) {
            return isFloating && task.getCompletion().isCompleted();
        } else {
            return isFloating && !task.getCompletion().isCompleted();
        }
    }

    @Override
    public String toString() {
        return "floating";
    }
}
```
###### /java/seedu/todo/model/qualifiers/FromTillDateQualifier.java
``` java
/**
 * A qualifier that filter tasks depending on the tasks starting 
 * and ending date.
 */
public class FromTillDateQualifier implements Qualifier{
  
    private LocalDateTime fromDateTime;
    private LocalDateTime tillDateTime;
    private SearchCompletedOption option;
    
    public FromTillDateQualifier(LocalDateTime fromDateTime, LocalDateTime tillDateTime, 
            SearchCompletedOption option) {
        this.fromDateTime = fromDateTime;
        this.tillDateTime = tillDateTime;
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate fromDate = task.getOnDate().getDate(); 
        LocalTime fromTime = task.getOnDate().getTime();
        
        LocalDate tillDate = task.getByDate().getDate(); 
        LocalTime tillTime = task.getByDate().getTime();
        
        boolean onFrom = false;
        boolean byTill = false;
        
        if (fromDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(fromDate, fromTime);
            onFrom = onDateTime.isAfter(fromDateTime.minusDays(1));
        }
        
        if (tillDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(tillDate, tillTime);
            byTill = onDateTime.isBefore(tillDateTime.plusDays(1));
        }
        
       
        boolean taskIsFromTill = onFrom && byTill; //must be in between the both dates
        
        if (option == SearchCompletedOption.ALL) {
            return taskIsFromTill;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsFromTill && task.getCompletion().isCompleted();
        } else {
            return taskIsFromTill && !task.getCompletion().isCompleted();
        }
            
    }

    @Override
    public String toString() {
        return "datetime=" + fromDateTime.toString() + " " + tillDateTime.toString();
    }
}
```
###### /java/seedu/todo/model/qualifiers/OnDateQualifier.java
``` java
/**
 * A qualifier that filter tasks based on whether their
 * starting date is on a certain date.
 */
public class OnDateQualifier implements Qualifier {
    
    private LocalDateTime datetime;
    private SearchCompletedOption option;
    private boolean hasTimeField;
    
    public OnDateQualifier(LocalDateTime datetime, boolean hasTimeField, SearchCompletedOption option) {
        this.datetime = datetime;
        this.option = option;
        this.hasTimeField = hasTimeField;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        boolean taskIsOnDate;
        
        if (task.getOnDate().getDate() != null) {
            if (this.hasTimeField) {
                LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(task.getOnDate().getDate(), 
                        task.getOnDate().getTime());
                taskIsOnDate = onDateTime.equals(datetime);            
            } else {
                LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(task.getOnDate().getDate(), 
                        task.getOnDate().getTime());
                taskIsOnDate = onDateTime.toLocalDate().equals(datetime.toLocalDate());
            }
        } else {
            taskIsOnDate = false;
        }

        if (option == SearchCompletedOption.ALL) {
            return taskIsOnDate;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsOnDate && task.getCompletion().isCompleted();
        } else {
            return taskIsOnDate && !task.getCompletion().isCompleted();
        }
        
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### /java/seedu/todo/model/task/Completion.java
``` java
/**
 * Represents a Task's completion.
 */
public class Completion {

    private boolean isCompleted;
    
    public Completion() {
        this(false);
    }
    
    public Completion(boolean completed) {
        this.isCompleted = completed;
    }
    
    public boolean isCompleted() {
        return this.isCompleted;
    }
    
    public void setCompletion(boolean completed) {
        this.isCompleted = completed;
    }
    
    public void toggle() {
        this.isCompleted = !this.isCompleted;
    }
    
    @Override
    public String toString() {
        return isCompleted ? "true" : "false";
    }
    
}
```
###### /java/seedu/todo/model/task/Detail.java
``` java
/**
 * Represents a Task's details in the to do application. 
 * Guarantees: mutable; no constraints.
 */
public class Detail {
    
    public String value;

    public Detail(String detail) {
        if (detail == null) {
            detail = "";
        }
        detail = detail.trim();
        this.value = detail;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Detail // instanceof handles nulls
                        && this.value.equals(((Detail) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### /java/seedu/todo/model/task/Name.java
``` java
/**
 * Represents a Task's name in the to do list.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS = "Task names should not be empty "
            + "and cannot contain semi-colons.\n"
            + "The max length of a task name is 120 characters";
    public static final String NAME_VALIDATION_REGEX = "[^;]+";
    public static final String ESCAPE = "'";
    public static final int MAX_CHAR_LENGTH = 120;
    
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        String tempName = name.trim().replace(ESCAPE, "");
        if (!isValidName(tempName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = tempName;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX) && test.length() <= MAX_CHAR_LENGTH;
    }


    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
```
###### /java/seedu/todo/model/task/ReadOnlyTask.java
``` java
    /**
     * Returns true if both have the same state. (interfaces cannot override .equals)
     */
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || ((other != null) // this is first to avoid NPE below
                && other.getName().equals(this.getName())
                && other.getDetail().equals(this.getDetail())
                && other.getByDate().equals(this.getByDate())
                && other.getOnDate().equals(this.getOnDate())
                && other.getPriority().equals(this.getPriority())
                && other.getRecurrence().equals(this.getRecurrence()));
    }

    /**
     * Formats the task as text, showing all task information.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append("Name: ")
                .append(getName() + "\n")
                .append("Details: ")
                .append(getDetail() + "\n")
                .append("Start: ")
                .append(getOnDate() + "\n")
                .append("End: ")
                .append(getByDate() + "\n")
                .append("Priority: ")
                .append(getPriority() + "\n")
                .append("Recurrence: ")
                .append(getRecurrence() + "\n");
        
        return builder.toString();
    }
```
###### /java/seedu/todo/model/task/Recurrence.java
``` java
/**
 * Represents a Task's name in the to do list.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Recurrence {
    
    public enum Frequency {
        NONE,
        YEAR,
        MONTH,
        WEEK,
        DAY
    }
    
    private Frequency freq;
    
    public Recurrence(Frequency freq) throws IllegalValueException {
        assert freq != null;
        this.freq = freq;
    }
    
    public Frequency getFreq() {
        return this.freq;
    }
    
    public void setFreq(Frequency freq) {
        this.freq = freq;
    }
        
    public boolean isRecurring() {
        return this.freq != Frequency.NONE;
    }
    
    @Override
    public String toString() {
        switch(this.freq) {
        case YEAR :
            return "YEAR";
        case MONTH :
            return "MONTH";
        case WEEK:
            return "WEEK";
        case DAY :
            return "DAY";
        default :
            return "NONE";
        }
    }
    
    /**
     * Update the dates for a task based on the recurrence of the task.
     * Will mark the task as undone as well.
     */
    public void updateTaskDate(Task task){
        
        task.getCompletion().setCompletion(false);
        
        switch(this.freq) {
        case YEAR :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusYears(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusYears(1));
            }
            break;
        case MONTH :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusMonths(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusMonths(1));
            }
            break;
        case WEEK:
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusWeeks(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusWeeks(1));
            }
            break;
        case DAY :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusDays(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusDays(1));
            }
            break;
        default :
            //Default value is NONE - do not need to update
        }
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Recurrence // instanceof handles nulls
                && this.freq.equals(((Recurrence) other).freq)); // state check
    }
    
}
```
###### /java/seedu/todo/model/task/Task.java
``` java
/**
 * Represents a Task in DoDo-Bird
 * Guarantees: all fields are not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private Detail detail;
    private TaskDate onDate;
    private TaskDate byDate; //deadline
    private Priority priority;
    private Completion completion;
    private UniqueTagList tags;
    private Recurrence recurrence;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, Detail detail, TaskDate fromDate, 
            TaskDate tillDate, Priority priority, Recurrence recurrence) {
        
        assert !CollectionUtil.isAnyNull(name, detail, fromDate, tillDate, recurrence);
        
        this.name = name;
        this.detail = detail;
        this.onDate = fromDate;
        this.byDate = tillDate;
        this.priority = priority;
        this.recurrence = recurrence;
        this.completion = new Completion(false);
        this.tags = new UniqueTagList(); // protect internal tags from changes in the arg list
    }
    
    public Task(Name name, Detail detail, Completion completion, TaskDate fromDate, 
            TaskDate tillDate, Priority priority, Recurrence recurrence, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, detail, fromDate, tillDate, completion, recurrence);
        this.name = name;
        this.detail = detail;
        this.onDate = fromDate;
        this.byDate = tillDate;
        this.priority = priority;
        this.completion = completion;
        this.recurrence = recurrence;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
    
    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDetail(), source.getCompletion(), source.getOnDate(), 
                source.getByDate(), source.getPriority(), source.getRecurrence(), source.getTags());
    }

    @Override
    public Name getName() {
        return this.name;
    }

    @Override
    public Detail getDetail() {
        return this.detail;
    }

    @Override
    public TaskDate getOnDate() {
        return this.onDate;
    }

    @Override
    public TaskDate getByDate() {
        return this.byDate;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }
    
    @Override
    public Completion getCompletion() {
        return this.completion;
    }
    
    @Override
    public Recurrence getRecurrence() {
        return this.recurrence;
    }
```
###### /java/seedu/todo/model/task/Task.java
``` java
    @Override
    public boolean isRecurring() {
        return this.recurrence.isRecurring();
    }
    
    public void setName(Name n) {
        this.name = n;
    }

    public void setDetail(Detail d) {
        this.detail = d;
    }

    public void setOnDate(TaskDate fd) {
        this.onDate = fd;
    }

    public void setByDate(TaskDate td) {
        this.byDate = td;
    }
```
###### /java/seedu/todo/model/task/Task.java
``` java
    public void setCompletion(Completion c) {
        this.completion = c;
    }
    
    public void setRecurrence(Recurrence r) {
        this.recurrence = r;
    }
    
```
###### /java/seedu/todo/model/task/TaskDate.java
``` java
/**
 * Represents the information for Task's date and time .
 * 
 * Guarantees: valid as long as natty can parse it. The parsing is done in using DateTimeUtil.
 */
public class TaskDate {

    public static final String MESSAGE_DATETIME_CONSTRAINTS = "Do-Do Bird is unable to recognise "
            + "the date and time you entered.\n Please try again! You can refer to our help manual"
            + " for acceptable date and time formats.\n"
            + "Type 'help' to launch the help manual.";
    
    
    public static final String TASK_DATE_ON = "START";
    public static final String TASK_DATE_BY = "END";
    
    private LocalDate date;
    private LocalTime time;
    
    /**
     * Validates given date and time string.
     *
     * @throws IllegalValueException if given date and time string is invalid.
     */
    public TaskDate(String dateTimeString, String onOrBy) throws IllegalValueException {
        
        assert onOrBy != null;
        
        if (DateTimeUtil.isEmptyDateTimeString(dateTimeString)) {
            this.date = null;
            this.time = null;
        } else {
            LocalDateTime ldt = DateTimeUtil.parseDateTimeString(dateTimeString, onOrBy);
            if (ldt == null) {
                throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
            } else {
                this.date = ldt.toLocalDate();
                this.time = ldt.toLocalTime();
            }  
        }
    }

    public LocalDate getDate() {
        return this.date;
    }
    
    public LocalTime getTime() {
        return this.time;
    }
    
    public LocalDate setDate(LocalDate date) {
        return this.date = date;
    }
    
    public LocalTime setTime(LocalTime time) {
        return this.time = time;
    }
    
```
###### /java/seedu/todo/model/task/TaskDate.java
``` java
    @Override
    public String toString() {
        String dateString;
        String timeString;
        
        if (date == null) {
            dateString = "";
        } else {
            dateString = DateTimeUtil.prettyPrintDate(date);
        }
        
        if (time == null) {
            timeString = "";
        } else {
            timeString = DateTimeUtil.prettyPrintTime(time);
        }

        return dateString + " " + timeString;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && ((this.date == null && ((TaskDate) other).date == null)
                || ((this.date != null && ((TaskDate) other).date != null)
                && DateTimeUtil.combineLocalDateAndTime(this.date, this.time)
                    .equals(DateTimeUtil.combineLocalDateAndTime(((TaskDate) other).date, ((TaskDate) other).time)))));
    }
    
```
###### /java/seedu/todo/storage/XmlAdaptedTask.java
``` java
    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        detail = source.getDetail().toString();
        completion = source.getCompletion().toString();
        onDate = source.getOnDate().toString();
        byDate = source.getByDate().toString();
        priority = source.getPriority().toString();
        recurrence = source.getRecurrence().toString();
        tagged = new ArrayList<>();
        
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
        
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
       
        final Name name = new Name(this.name);
        final Detail detail = new Detail(this.detail);
        final Completion completion = new Completion(Boolean.parseBoolean(this.completion));
        final TaskDate onDate = new TaskDate(this.onDate, TaskDate.TASK_DATE_ON);
        final TaskDate byDate = new TaskDate(this.byDate, TaskDate.TASK_DATE_BY);
        final Priority priority = new Priority(this.priority);
        final Recurrence recurrence = new Recurrence(Frequency.valueOf(this.recurrence));
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(name, detail, completion, onDate, byDate, priority, recurrence, tags);
    }
}
```
###### /java/seedu/todo/ui/CardStyler.java
``` java
/**
 * styling methods for taskcard 
 *
 */
public class CardStyler {
    
    public static Color COMPLETION_COLOR = Color.LIGHTGREY;
    public static Color COMPLETION_PRIORITY_COLOR = Color.WHITE;
    public static Color OVERDUE_COLOR = Color.web("#ef5350");
    
    public static void styleForCompletion(Text name, Text details, Text onDate, 
            Text byDate, Text tags, Text recurrence, Circle priorityLevel) {
        
        name.setFill(COMPLETION_COLOR);
        name.setStyle("-fx-strikethrough: true");
        name.setOpacity(50);
        
        details.setFill(COMPLETION_COLOR);
        onDate.setFill(COMPLETION_COLOR);
        byDate.setFill(COMPLETION_COLOR);
        recurrence.setFill(COMPLETION_COLOR);
        tags.setFill(COMPLETION_COLOR);

        priorityLevel.setFill(COMPLETION_PRIORITY_COLOR);
        priorityLevel.setStroke(COMPLETION_PRIORITY_COLOR);

    }
    
    public static void styleForOverdue(Text name, Text details, Text onDate, 
            Text byDate, Text tags, Text recurrence) {
        name.setFill(OVERDUE_COLOR);
        details.setFill(OVERDUE_COLOR);
        onDate.setFill(OVERDUE_COLOR);
        byDate.setFill(OVERDUE_COLOR);
        recurrence.setFill(OVERDUE_COLOR);
        tags.setFill(OVERDUE_COLOR);
    }
}
```
###### /java/seedu/todo/ui/CommandBox.java
``` java
    private Stack<String> commandHistory = new Stack<>();
    private Stack<String> commandFuture = new Stack<>();
```
###### /java/seedu/todo/ui/CommandBox.java
``` java
    @FXML
    private void handleKeyPressed(KeyEvent e) {
        if (e.getCode().toString().equals("UP") && !commandHistory.isEmpty()) {
            String c = commandHistory.pop();
            commandFuture.push(c);
            commandTextField.setText(c);
        }
        if (e.getCode().toString().equals("DOWN") && !commandFuture.isEmpty()) {
            String c = commandFuture.pop();
            commandHistory.push(c);
            commandTextField.setText(c);
        }
    }
```
###### /java/seedu/todo/ui/PrettifyDate.java
``` java
public class PrettifyDate {

    public static final int THRESHOLD = 3;
    
    /**
     * Prettify the date for UI printing.
     */
    public static String prettifyDate(LocalDate date) {
        LocalDate today = LocalDate.now();
        
        if (date.equals(today)) {
            return "Today";
        }
        if (date.plusDays(1).equals(today)) {
            return "Yesterday";
        }
        if (date.minusDays(1).equals(today)) {
            return "Tomorrow";
        }
        
        if (date.isBefore(today) && today.minusDays(THRESHOLD).isBefore(date)) {
            int diff = Math.abs((int) ChronoUnit.DAYS.between(today, date));
            return diff + " days ago";
        } else if (date.isAfter(today) && today.plusDays(THRESHOLD).isAfter(date)) {
            int diff = Math.abs((int) ChronoUnit.DAYS.between(today, date));
            return diff + " days later";
        }
        
        return date.format(DateTimeFormatter.ofPattern("dd-MMM-YYYY"));
        
    }
     
    
}
```
###### /java/seedu/todo/ui/StatusBarFooter.java
``` java
    @Subscribe
    public void handleSaveLocationChangedEvent(SaveLocationChangedEvent slce) {
        setSaveLocation(slce.toString());
    }
    
}
```
###### /java/seedu/todo/ui/TaskCard.java
``` java
    private void initOnDate() {
        if (task.getOnDate().getDate() != null) {
            onDate.setText("Start: " 
            			+ PrettifyDate.prettifyDate(task.getOnDate().getDate()) 
                        + " @ " + task.getOnDate().getTime() + " hrs");
        } else {
            onDate.setText("");
        }
    }
    
    private void initByDate() {
        if (task.getByDate().getDate() != null) {
            byDate.setText("End: " 
            			+ PrettifyDate.prettifyDate(task.getByDate().getDate()) 
                        + " @ " + task.getByDate().getTime() + " hrs");
        } else {
            byDate.setText("");
        }
    }
    
    private void initRecurrence() {
        if (task.isRecurring()) {
            recurrence.setText("Every: " + task.getRecurrence().toString());
        } else {
            recurrence.setText("");
        }
    }
    
    
```
