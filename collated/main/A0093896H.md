# A0093896H
###### \java\seedu\todo\commons\core\Config.java
``` java
    public static final String DEFAULT_CONFIG_FILE = "defaultConfig.json";
```
###### \java\seedu\todo\commons\util\DateTimeUtil.java
``` java
package seedu.todo.commons.util;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.time.LocalDateTime;

import com.joestelmach.natty.*;

import seedu.todo.model.task.TaskDate;

/**
 * Helper functions for anything with regards to date and time.
 */
public class DateTimeUtil {


    public static final int DEFAULT_ON_HOUR = 0;
    public static final int DEFAULT_ON_MINUTE = 0;        
    public static final int DEFAULT_BY_HOUR = 23;
    public static final int DEFAULT_BY_MINUTE = 59;
    
    public static boolean isEmptyDateTimeString(String dateTimeString) {
        return (dateTimeString == null || dateTimeString.equals("") || dateTimeString.equals(" "));
    }

    /**
     * Attempts to parse a String into LocalDateTime.
     * 
     * If the String does not contains date information, the default date used is the current date.
     * 
     * If the String does not contains time information, the default time used is the 0000hrs if
     * it is an onDate and 2359 if it is a byDate.
     * 
     * @param dateTimeString
     * @param onOrBy
     * @return LocalDateTime
     */
    public static LocalDateTime parseDateTimeString(String dateTimeString, String onOrBy) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);

        if (groups.size() == 0) {
            return null;
        } else {
            Map<String, List<ParseLocation>> m = groups.get(0).getParseLocations();
            Date date = groups.get(0).getDates().get(0);
            
            Calendar c = Calendar.getInstance();
            c.setTime(date);
            
            LocalDateTime ldt;
            if (!m.keySet().contains("date")) {
                LocalDateTime now = LocalDateTime.now();
                ldt = LocalDateTime.of(now.getYear(), now.getMonth(), now.getDayOfMonth(), 
                        c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE));
            } else {
                if (!m.keySet().contains("explicit_time")) {
                    if (onOrBy.equals(TaskDate.TASK_DATE_BY)) {
                        ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                                c.get(Calendar.DATE), DEFAULT_BY_HOUR, DEFAULT_BY_MINUTE);
                    } else {
                        ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                                c.get(Calendar.DATE), DEFAULT_ON_HOUR, DEFAULT_ON_MINUTE);
                    }
                } else {
                    ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                            c.get(Calendar.DATE), c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE));
                }
                
            }
            
            return ldt;
        }
    }

    /**
     * Checks whether date information is able to be parsed out 
     * from a String
     * 
     * @param dateTimeString
     * @return boolean
     */
    public static boolean containsDateField(String dateTimeString) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);
        
        if (groups.size() == 0) {
            return false;
        } else {
            DateGroup group = groups.get(0);
            Map<String, List<ParseLocation>> m = group.getParseLocations();
            return m.keySet().contains("date");
        }
    }
    
    /**
     * Checks whether time information is able to be parsed out 
     * from a String
     * 
     * @param dateTimeString
     * @return boolean
     */
    public static boolean containsTimeField(String dateTimeString) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);
        
        if (groups.size() == 0) {
            return false;
        } else {
            DateGroup group = groups.get(0);
            Map<String, List<ParseLocation>> m = group.getParseLocations();
            return m.keySet().contains("explicit_time");
        }
    }
    
    /**
     * Checks whether onDate is before byDate
     * 
     * @param onDate
     * @param byDate
     * @return boolean
     */
    public static boolean beforeOther(TaskDate onDate, TaskDate byDate) {
        if (onDate.getDate() == null || byDate.getDate() == null) {
            return true;
        } else if (onDate.getDate().equals(byDate.getDate())) {
            return onDate.getTime().isBefore(byDate.getTime());
        } else {
            return onDate.getDate().isBefore(byDate.getDate());
        }
    }
    
    /**
     * Combines LocalDate and LocalTime to LocalDateTime with default time being 2359
     * @param date
     * @param time
     * @return
     */
    public static LocalDateTime combineLocalDateAndTime(LocalDate date, LocalTime time) {
        assert date != null;
        if (time == null) {
            return LocalDateTime.of(date.getYear(), date.getMonth(), date.getDayOfMonth(), 23, 59);
        } else {
            return LocalDateTime.of(date, time);
        }
    }
    
    
    public static String prettyPrintDate(LocalDate date) {
        return date.format(DateTimeFormatter.ofPattern("dd MMM yyyy"));
    }

    public static String prettyPrintTime(LocalTime time) {
        return time.format(DateTimeFormatter.ofPattern("hh:mm a"));
    }

}
```
###### \java\seedu\todo\logic\commands\AddCommand.java
``` java
package seedu.todo.logic.commands;

import java.time.LocalDate;

import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.*;
import seedu.todo.model.task.Recurrence.Frequency;

/**
 * Adds a task into DoDo-Bird
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the to do list. "
            + "Parameters: TASKNAME on STARTDATE by ENDDATE priority PRIORITY every RECURRENCE; DETAILS...\n"
            + "Example: " + COMMAND_WORD
            + " get groceries on 10/10/2016 by 11/10/2016 ; bread, fruits, cinnamon powder, red pepper";

    public static final String MESSAGE_SUCCESS = "New task added! Name : %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the to do list";
    public static final String MESSAGE_INVALID_DATE_RANGE = "Cannot have on date later than by date";
    
    private final Task toAdd;
    
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String detail, String onDateString, 
                      String byDateString, String priority, Frequency freq)
                      throws IllegalValueException {
        
        TaskDate onDate = new TaskDate(onDateString, TaskDate.TASK_DATE_ON);
        TaskDate byDate = new TaskDate(byDateString, TaskDate.TASK_DATE_BY);
        
        if (byDate.getDate() != null && !DateTimeUtil.containsDateField(byDateString)) {
            
            byDate.setDate(LocalDate.of(onDate.getDate().getYear(), 
                    onDate.getDate().getMonth(), onDate.getDate().getDayOfMonth()));
        }
        
        if (!DateTimeUtil.beforeOther(onDate, byDate)) {
            throw new IllegalValueException(MESSAGE_INVALID_DATE_RANGE);
        }
        this.toAdd = new Task(
                new Name(name),
                new Detail(detail),
                onDate,
                byDate,
                new Priority(priority),
                new Recurrence(freq)
        );
    }
    //
    /**
     * Executes the add command. The new task is added to the top of the list.
     * 
     * Informs the user if duplicated task is added.
     * Refer to {@link seedu.todo.model.task.ReadOnlyTask#isSameStateAs(ReadOnlyTask)} 
     * for equivalence testing.
     */
    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            model.updateFilteredListToShowAllNotCompleted();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }

}
```
###### \java\seedu\todo\logic\commands\DeleteCommand.java
``` java
    /**
     * Executes the delete command.
     * 
     * Will inform the user if an invalid index is used or the task cannot be found. 
     */
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.deleteTask(taskToDelete);
            model.updateFilteredListToShowAllNotCompleted();
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_TASK_NOT_FOUND);
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete.getName()));
    }

}
```
###### \java\seedu\todo\logic\commands\MarkCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.model.task.Completion;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Marks a task identified using it's last displayed index from the to do list.
 */
public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Mark Task: Name : %1$s";

    public final int targetIndex;

    public MarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    /**
     * Executes the Mark Command
     * 
     * Will return a message to inform the user if an invalid target index is used 
     * or the task specified cannot be found,
     */
    @Override
    public CommandResult execute() {
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
        
        try {
            Task toMark = model.getTask(taskToMark);
            
            toMark.setCompletion(new Completion(true));

            model.updateTask(taskToMark, toMark);
            model.updateFilteredListToShowAllCompleted();
            
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_TASK_NOT_FOUND);
        } 

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToMark.getName()));
    }
}
```
###### \java\seedu\todo\logic\commands\ResetCommand.java
``` java
package seedu.todo.logic.commands;

import java.io.IOException;
import java.util.Optional;

import seedu.todo.commons.core.Config;
import seedu.todo.commons.exceptions.DataConversionException;
import seedu.todo.commons.util.ConfigUtil;

/**
 * Reset Config to default
 */
public class ResetCommand extends Command {

    public static final String COMMAND_WORD = "reset";

    public static final String MESSAGE_SUCCESS = "Reset User Config !";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reset the user config to default"
            + "Example: " + COMMAND_WORD;
    
    public static final String MESSAGE_SAVE_ERROR = "Unable to save config to new location.";
    
    public ResetCommand() {}
    
    
    /**
     * Executes the Reset Command.
     * 
     * Informs the user if unable to save config at default location.
     */
    @Override
    public CommandResult execute() {
        
        String configFilePathUsed = Config.DEFAULT_CONFIG_FILE;
        
        Config initializedConfig;
        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(configFilePathUsed);
            initializedConfig = configOptional.orElse(new Config());
        } catch (DataConversionException e) {
            initializedConfig = new Config();
        } 
        
        try {
            ConfigUtil.saveConfig(initializedConfig, Config.USER_CONFIG_FILE);
            config.setAppTitle(initializedConfig.getAppTitle());
            config.setLogLevel(initializedConfig.getLogLevel());
            config.setToDoListFilePath(initializedConfig.getToDoListFilePath());
            config.setToDoListName(initializedConfig.getToDoListName());
            config.setUserPrefsFilePath(initializedConfig.getUserPrefsFilePath());

            storage.setToDoListFilePath(config.getToDoListFilePath());
            storage.saveToDoList(model.getToDoList());
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_SAVE_ERROR);
        }
          
    }
        
   
}
```
###### \java\seedu\todo\logic\commands\SearchCommand.java
``` java
package seedu.todo.logic.commands;

import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.Priority;
import seedu.todo.model.task.TaskDate;

/**
 * Finds and lists all the task in DoDoBird based on the search option and arguments
 * Keyword matching is case insensitive.
 */
public class SearchCommand extends Command {

    public enum SearchIndex {
        ON,
        BEFORE,
        AFTER,
        KEYWORD,
        TAG,
        DONE,
        UNDONE,
        FT,
        PRIORITY,
    }
    
    public enum SearchCompletedOption {
        ALL,
        DONE,
        UNDONE,
    }
    
    
    public static final String COMMAND_WORD = "search";
    public static final String FT_CONCATENATER = "@";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Search all tasks whose names contain any of "
            + "the specified keywords and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " birthday homework friday";

    private final String data;
    private final SearchIndex whichSearch;
    private final SearchCompletedOption option;
    
    public SearchCommand(String data, SearchCompletedOption option, SearchIndex whichSearch) {
        this.data = data;
        this.whichSearch = whichSearch;
        this.option = option;
    }

    /**
     * Executes the Search command
     * 
     * Performs the search depending on the the search option
     */
    @Override
    public CommandResult execute() {
        switch (this.whichSearch) {
        case ON : 
            return searchOn();
            
        case BEFORE : 
            return searchBefore();
            
        case AFTER : 
            return searchAfter();
            
        case FT : 
            return searchFT();
            
        case KEYWORD : 
            return searchKeyword();
            
        case TAG : 
            return searchTag();
            
        case DONE :
            return searchDone();
                    
        case UNDONE : 
            return searchUndone();
    
        case PRIORITY : 
            return searchPriority();
                    
        default :
            return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }        
    }

    /**
     * Search tasks that falls on a certain date
     */
    private CommandResult searchOn() {
        try {
            LocalDateTime datetime = DateTimeUtil.parseDateTimeString(data, TaskDate.TASK_DATE_ON);
            model.updateFilteredTaskListOnDate(datetime, this.option);
            int size = model.getFilteredTaskList().size();
            return new CommandResult(getMessageForTaskListShownSummary(size));
            
        } catch (DateTimeParseException e) {
            return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }
    
    /**
     * Search tasks that falls before a certain date
     */
    private CommandResult searchBefore() {
        try {
            LocalDateTime datetime = DateTimeUtil.parseDateTimeString(data, TaskDate.TASK_DATE_BY);
            model.updateFilteredTaskListBeforeDate(datetime, this.option);
                
            int size = model.getFilteredTaskList().size();
            return new CommandResult(getMessageForTaskListShownSummary(size));
                
        } catch (DateTimeParseException e) {
            return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }
    
    /**
     * Search tasks that falls after a certain date
     */
    private CommandResult searchAfter() {
        try {
            LocalDateTime datetime = DateTimeUtil.parseDateTimeString(data, TaskDate.TASK_DATE_ON);
            model.updateFilteredTaskListAfterDate(datetime, this.option);
                
            int size = model.getFilteredTaskList().size();
            return new CommandResult(getMessageForTaskListShownSummary(size));
                
        } catch (DateTimeParseException e) {
            return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }
    
    /**
     * Search tasks that falls from a certain date to another date
     */
    private CommandResult searchFT() {
        try {
            String fromDateString = data.split(FT_CONCATENATER)[0].trim();
            LocalDateTime fromDateTime = DateTimeUtil.parseDateTimeString(fromDateString, TaskDate.TASK_DATE_ON);
                
            String tillDateString = data.split(FT_CONCATENATER)[1].trim();
            LocalDateTime tillDateTime = DateTimeUtil.parseDateTimeString(tillDateString, TaskDate.TASK_DATE_BY);
                
            model.updateFilteredTaskListFromTillDate(fromDateTime, tillDateTime, this.option);
            
            int size = model.getFilteredTaskList().size();
            return new CommandResult(getMessageForTaskListShownSummary(size));
                
        } catch (DateTimeParseException e) {
            return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }
    
    /**
     * Search tasks based on keywords
     * Search is case insensitive
     * Will match the keywords in the tasks names and details.
     */
    private CommandResult searchKeyword() {
        final String[] keywords = data.split("\\s+");
        final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
        model.updateFilteredTaskListByKeywords(keywordSet, this.option);
        
        int size = model.getFilteredTaskList().size();
        return new CommandResult(getMessageForTaskListShownSummary(size));
    }
    
    /**
     * Search tasks that have a certain tag
     */
    private CommandResult searchTag() {
        model.updateFilteredTaskListByTag(data.trim(), this.option);
        
        int size = model.getFilteredTaskList().size();
        return new CommandResult(getMessageForTaskListShownSummary(size));
    }
    
    
    /**
     * Search tasks that based on their priority level
     */
    private CommandResult searchPriority() {
        try {
            String priority = data.trim();                   
            model.updateFilteredTaskListByPriority(new Priority(priority), this.option);
           
            int size = model.getFilteredTaskList().size();
            return new CommandResult(getMessageForTaskListShownSummary(size));
               
        } catch (IllegalValueException e) {
            return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
    }
    
    /**
     * Search tasks that are completed
     */
    private CommandResult searchDone() {
        model.updateFilteredListToShowAllCompleted();

        int size = model.getFilteredTaskList().size();
        return new CommandResult(getMessageForTaskListShownSummary(size));
    }
    
    /**
     * Search tasks that are not completed
     */
    private CommandResult searchUndone() {
        model.updateFilteredListToShowAllNotCompleted();
        
        int size = model.getFilteredTaskList().size();
        return new CommandResult(getMessageForTaskListShownSummary(size));
    }
     
}
```
###### \java\seedu\todo\logic\commands\StoreCommand.java
``` java
package seedu.todo.logic.commands;

import java.io.IOException;

import seedu.todo.commons.core.Config;
import seedu.todo.commons.util.ConfigUtil;
import seedu.todo.commons.util.FileUtil;


/**
 * Change data storage location
 */
public class StoreCommand extends Command {

    public static final String COMMAND_WORD = "store";

    public static final String MESSAGE_SUCCESS = "Change storage location !";
    
    public static final String MESSAGE_SAVE_ERROR = "Unable to save to new location.";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Changes the storage location to the location specified by the user. "
            + "Parameters: NEW_STORAGE_LOCATION\n"
            + "Example: " + COMMAND_WORD + "data/dodobird.xml";

    private final String location;
    
    public StoreCommand(String newLocation) {
        this.location = newLocation;
    }
    
    /**
     * Executes the store command.
     * 
     * Checks if the newly specified location is valid and save to the location if so.
     * If the specified location is not valid, reset the location to default location. 
     */
    @Override
    public CommandResult execute() {
        String defaultLocation = config.getToDoListFilePath();
        String tempLocation = this.location + "/" + config.getToDoListName() + ".xml";
        
        if (FileUtil.isFilenameValid(tempLocation)) {
            try {
                config.setToDoListFilePath(tempLocation);
                ConfigUtil.saveConfig(config, Config.USER_CONFIG_FILE);
                storage.setToDoListFilePath(tempLocation);
                storage.saveToDoList(model.getToDoList());
                return new CommandResult(MESSAGE_SUCCESS);
            } catch (IOException e){
                config.setToDoListFilePath(defaultLocation);
                storage.setToDoListFilePath(defaultLocation);
                return new CommandResult(MESSAGE_SAVE_ERROR);
            }
        } else {
            return new CommandResult(MESSAGE_SAVE_ERROR);
        }
          
    }
        
   
}
```
###### \java\seedu\todo\logic\commands\TagCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Tags a task identified using it's last displayed index from the to do list.
 * with tags
 */
public class TagCommand extends Command{

    public static final String COMMAND_WORD = "tag";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Tags the task identified by the index number used in the last task listing. "
            + "Tag name must be unique\n"
            + "Parameters: INDEX TAGNAME [MORE TAGNAMES]\n"
            + "Example: " + COMMAND_WORD + " 1 birthday clique";

    public static final String MESSAGE_SUCCESS = "Tagged Task: Name : %1$s";

    public final int targetIndex;
    public final UniqueTagList tags;
    
    public TagCommand(int targetIndex, String tagNames) throws IllegalValueException {

        this.targetIndex = targetIndex;
        
        if (tagNames.isEmpty()) {
            throw new IllegalValueException("Tag Names cannot be empty");
        }
        
        tags = new UniqueTagList();
        for (String tagName : tagNames.trim().split(" ")) {
            tags.add(new Tag(tagName));
        }
        
    }
    
    /**
     * Executes the tag command.
     * 
     * If the index is invalid or if the specified task cannot be found, returns the 
     * relevant message to inform the user.
     */
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToTag = lastShownList.get(targetIndex - 1);

        try {
            model.addTaskTags(taskToTag, tags);
            model.updateFilteredListToShowAllNotCompleted();
        } catch (TaskNotFoundException e) {
            return new CommandResult(Messages.MESSAGE_TASK_NOT_FOUND);
        }
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToTag.getName()));
    }
    
    
    
}
```
###### \java\seedu\todo\logic\commands\UndoCommand.java
``` java
package seedu.todo.logic.commands;

/**
 * Undoes the user's last action
 */
public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo the previous command";
    public static final String MESSAGE_NO_PREVIOUS_STATE = "There is no previous state to return to.";

    public UndoCommand() {}

    @Override
    public CommandResult execute() {
        if (model.undo()) {
            return new CommandResult(MESSAGE_SUCCESS);
        } else {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_NO_PREVIOUS_STATE);
        }

    }
}
```
###### \java\seedu\todo\logic\commands\UnmarkCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.model.task.Completion;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Unmark a task identified using it's last displayed index from the to do list.
 */
public class UnmarkCommand extends Command {
    
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unmarks the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Unmark Task: %1$s";

    public final int targetIndex;

    public UnmarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    /**
     * Executes the unmark Command
     * 
     * Will return a message to inform the user if an invalid target index is used 
     * or the task specified cannot be found,
     */
    @Override
    public CommandResult execute() {
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
        
        try {
            Task toMark = model.getTask(taskToMark);
            
            toMark.setCompletion(new Completion(false));
            
            model.updateTask(taskToMark, toMark);
            model.updateFilteredListToShowAllNotCompleted();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be found";
        } 
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToMark.getName()));
    }
}
```
###### \java\seedu\todo\logic\commands\UntagCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Tags a task identified using it's last displayed index from the to do list.
 * with tags
 */
public class UntagCommand extends Command{

    public static final String COMMAND_WORD = "untag";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Untags the task identified by the index number used in the last task listing. "
            + "Tag names must be unique\n"
            + "Parameters: INDEX TAGNAME [MORE TAGNAMES]\n"
            + "Example: " + COMMAND_WORD + " 1 birthday clique";

    public static final String MESSAGE_SUCCESS = "Untagged Task: %1$s";

    public final int targetIndex;
    public final UniqueTagList tags;
    
    public UntagCommand(int targetIndex, String tagNames) throws IllegalValueException {

        this.targetIndex = targetIndex;
        
        if (tagNames.isEmpty()) {
            throw new IllegalValueException("Tag Names cannot be empty");
        }
        
        tags = new UniqueTagList();
        for (String tagName : tagNames.trim().split(" ")) {
            tags.add(new Tag(tagName));
        }
        
    }
    
    /**
     * Executes the untag command.
     * 
     * If the index is invalid or if the specified task cannot be found, returns the 
     * relevant message to inform the user.
     */
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUntag = lastShownList.get(targetIndex - 1);

        try {
            model.deleteTaskTags(taskToUntag, tags);
            model.updateFilteredListToShowAll();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be found";
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToUntag.getName()));
    }
    
    
    
}
```
###### \java\seedu\todo\logic\commands\UpdateCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.Detail;
import seedu.todo.model.task.Name;
import seedu.todo.model.task.Priority;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Recurrence;
import seedu.todo.model.task.Recurrence.Frequency;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.TaskDate;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Updates a task identified using it's last displayed index from the to do list.
 */
public class UpdateCommand extends Command {

    public static final String COMMAND_WORD = "update";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Update the task identified by the index number used in the last task listing. \n"
            + "Prefix a - sign in front of optional fields you wished to remove.\n"
            + "Parameters: ID [NEW_NAME] [[-]on DATE [tTime]] [[-]by DATE [tTime]] [[-]; a line of new details]\n"
            + "Example: " + COMMAND_WORD + " 2 on 14/10/2017 by 18/10/2017 ";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Update Task: %1$s";
    public static final String MESSAGE_INVALID_DATE_RANGE = "Cannot have on date later than by date";
    
    private final int targetIndex;
    
    private final String name;
    private final String detail;
    private final String onDateTime;
    private final String byDateTime;
    private final String priority;
    private final String recurrence;
    
    /**
     * Takes in the raw value for each data field. Does not provide validation check 
     * at this juncture.
     * 
     * @param targetIndex
     * @param name
     * @param onDateTime
     * @param byDateTime
     * @param detail
     * @param priority
     * @param recurrence
     */
    public UpdateCommand(int targetIndex, String name, String onDateTime, 
            String byDateTime, String detail, String priority, String recurrence) {
        this.targetIndex = targetIndex;
        this.name = name;
        this.detail = detail;
        this.onDateTime = onDateTime;
        this.byDateTime = byDateTime;
        this.priority = priority;
        this.recurrence = recurrence;
    }
    
    /**
     * Executes the update command.
     * Constructs a new task to be the replicated by the old task in model.
     * 
     * TODO: Add validation check for on date before by date
     */
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(targetIndex - 1);
        
        try {            
            Name newName = this.makeNewName(taskToUpdate);
            Detail newDetail = this.makeNewDetail(taskToUpdate);
            TaskDate newByDate = this.makeNewByDate(taskToUpdate);
            TaskDate newOnDate = this.makeNewOnDate(taskToUpdate);
            Priority newPriority = this.makeNewPriority(taskToUpdate);
            Recurrence newRecurrence = this.makeNewRecurrence(taskToUpdate);
            
            if (!DateTimeUtil.beforeOther(newOnDate, newByDate)) {
                throw new IllegalValueException(MESSAGE_INVALID_DATE_RANGE);
            }
            
            Task newTask = new Task(newName, newDetail, taskToUpdate.getCompletion(), 
                    newOnDate, newByDate, newPriority, newRecurrence, taskToUpdate.getTags());
            
            model.updateTask(taskToUpdate, newTask);
            model.updateFilteredListToShowAllNotCompleted();
            model.updateTodayListToShowAll(); 
            model.updateWeekListToShowAll();
            return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, newTask));
            
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(Messages.MESSAGE_TASK_NOT_FOUND);
        
        } catch (IllegalValueException e) {
            return new CommandResult(e.getMessage());
        }
        
    }
    
    /**
     * Construct a new Name based on user input
     */
    private Name makeNewName(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        return this.name.equals("") ? taskToUpdate.getName() : new Name(this.name);
    }
    
    /**
     * Construct a new Detail based on user input
     */
    private Detail makeNewDetail(ReadOnlyTask taskToUpdate) {
        Detail newDetail;
        if (this.detail == null) {
            newDetail = taskToUpdate.getDetail();
        } else {
            newDetail = this.detail.trim().equals("-") 
                    ?  new Detail(null) 
                    : new Detail(this.detail);
        }
        return newDetail;
    }
    
    /**
     * Construct a new ByDate based on user input
     */
    private TaskDate makeNewByDate(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        TaskDate newByDate;
        if (this.byDateTime == null) {
            newByDate = taskToUpdate.getByDate();
        } else {
            newByDate = this.byDateTime.trim().equals("-") 
                    ?  new TaskDate("", TaskDate.TASK_DATE_BY) 
                    : new TaskDate(this.byDateTime, TaskDate.TASK_DATE_BY);
        }
        return newByDate;
    }
    
    /**
     * Construct a new OnDate based on user input
     */
    private TaskDate makeNewOnDate(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        TaskDate newOnDate;
        if (this.onDateTime == null) {
            newOnDate = taskToUpdate.getOnDate();
        } else {
            newOnDate = this.onDateTime.trim().equals("-") 
                    ?  new TaskDate("", TaskDate.TASK_DATE_ON) 
                    : new TaskDate(this.onDateTime, TaskDate.TASK_DATE_ON);
        }
        return newOnDate;
    }
    
    /**
     * Construct a new Recurrence based on user input
     */
    private Recurrence makeNewRecurrence(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        Recurrence newRecurrence;
        if (this.recurrence == null) {
            newRecurrence = taskToUpdate.getRecurrence();
        } else {
            newRecurrence = this.recurrence.trim().equals("-") 
                    ?  new Recurrence(Frequency.NONE) 
                    : new Recurrence(Frequency.valueOf(this.recurrence.toUpperCase().trim()));
        }
        return newRecurrence;
    } 
    
```
###### \java\seedu\todo\logic\parser\ParserFormats.java
``` java
package seedu.todo.logic.parser;

import java.util.regex.Pattern;


/**
 * Contains the various regex Patterns that ToDoListParser will use 
 * for the different commands.
 */
public class ParserFormats {
    
    public static final int FIRST_INDEX = 0;
    public static final String PRIORITY_FORMAT = " priority (?<priority>[^;]+)";
    public static final String ON_DATE_FORMAT = " (on|from) (?<onDateTime>[^;]+)";
    public static final String BY_DATE_FORMAT = " (by|to) (?<byDateTime>[^;]+)";
    public static final String DETAIL_FORMAT = "(?: ?; ?(?<detail>.+))?";
    public static final String NAME_FORMAT = "(?<name>[^/;]+)";
    public static final String RECUR_FORMAT = " every (?<rec>[^;]+)";
            
    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    public static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");
    
    //one or more keywords separated by whitespace
    public static final Pattern KEYWORDS_ARGS_FORMAT = Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); 
    
    public static final Pattern ADD_TASK_ARGS_FORMAT_FT = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + BY_DATE_FORMAT 
                    + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_FORMAT_ON = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + DETAIL_FORMAT, 
                    Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_FORMAT_BY = Pattern
            .compile(NAME_FORMAT + BY_DATE_FORMAT + DETAIL_FORMAT, 
                    Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_FORMAT_FLOAT = Pattern
            .compile(NAME_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);
    
    public static final Pattern ADD_TASK_ARGS_RECUR_FORMAT_FT = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + BY_DATE_FORMAT 
                    + RECUR_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_RECUR_FORMAT_ON = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + RECUR_FORMAT 
                    + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_RECUR_FORMAT_BY = Pattern
            .compile(NAME_FORMAT + BY_DATE_FORMAT + RECUR_FORMAT 
                    + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);
    
```
###### \java\seedu\todo\logic\parser\ParserFormats.java
``` java
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_ON = Pattern
            .compile("on (?<onDateTime>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_BEFORE = Pattern
            .compile("before (?<beforeDateTime>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_AFTER = Pattern
            .compile("after (?<afterDateTime>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_FT = Pattern
            .compile("from (?<fromDateTime>.+?) to (?<tillDateTime>.+?)(?<comOpt> done|all|undone)?", 
                    Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_TASK_ARGS_FORMAT_TAG = Pattern
            .compile("tag (?<tags>.+?)(?<comOpt> done|all|undone)?", Pattern.CASE_INSENSITIVE);
    
    public static final Pattern SEARCH_KEYWORDS_ARGS_FORMAT = Pattern
            .compile("(?<keywords>.+?)(?<comOpt> done|all|undone)?"); 
    
```
###### \java\seedu\todo\logic\parser\ParserFormats.java
``` java
    public static final Pattern UPDATE_TASK_ARGS_FORMAT = Pattern
            .compile("(?<name>[^/]*?)? "
                      + "?((^| )((on|from) (?<onDateTime>[^;]+?)?"
                      + "|by (?<byDateTime>[^;]+?)"
                      + "|priority (?<priority>[^;]+?)"
                      + "|every (?<rec>[^;]+?)))*?"
                      + "(?: ?;(?<detail>.+))?$", Pattern.CASE_INSENSITIVE);

    public static final Pattern RECURRENCE_WEEK_DAY = Pattern
            .compile("every (monday|tuesday|wednesday|thursday|friday|saturday|sunday|mon|tue|wed|thurs|fri|sat|sun)");
    
}
```
###### \java\seedu\todo\logic\parser\ToDoListParser.java
``` java
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = ParserFormats.BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case MarkCommand.COMMAND_WORD:
            return prepareMark(arguments);

        case SearchCommand.COMMAND_WORD:
            return prepareSearch(arguments);

        case SeeCommand.COMMAND_WORD:
            return new SeeCommand();

        case TagCommand.COMMAND_WORD:
            return prepareTag(arguments);

        case UntagCommand.COMMAND_WORD:
            return prepareUntag(arguments);

        case UnmarkCommand.COMMAND_WORD:
            return prepareUnmark(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();

        case UpdateCommand.COMMAND_WORD:
            return prepareUpdate(arguments);
            
        case StoreCommand.COMMAND_WORD:
            return prepareStore(arguments);
            
        case ResetCommand.COMMAND_WORD:
            return new ResetCommand();


        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
```
###### \java\seedu\todo\logic\parser\ToDoListParser.java
``` java
    private Command prepareAdd(String args) {
        
        Pattern[] dataPatterns = {ParserFormats.ADD_PRIORITY_FT, ParserFormats.ADD_PRIORITY_ON, 
                ParserFormats.ADD_PRIORITY_BY, ParserFormats.ADD_PRIORITY_FL, 
                ParserFormats.ADD_TASK_ARGS_RECUR_FORMAT_FT, ParserFormats.ADD_TASK_ARGS_RECUR_FORMAT_BY, 
                ParserFormats.ADD_TASK_ARGS_RECUR_FORMAT_ON, ParserFormats.ADD_TASK_ARGS_FORMAT_FT, 
                ParserFormats.ADD_TASK_ARGS_FORMAT_BY, ParserFormats.ADD_TASK_ARGS_FORMAT_ON, 
                ParserFormats.ADD_TASK_ARGS_FORMAT_FLOAT};
       
        Matcher matcher;
        try {
            for (Pattern p : dataPatterns) {
                matcher = p.matcher(args.trim());
                if (matcher.matches()) {
                    if (p.equals(ParserFormats.ADD_TASK_ARGS_FORMAT_FT)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), matchOnDateTimeResult(matcher), 
                                matchByDateTimeResult(matcher), Priority.DEFAULT_PRIORITY, 
                                Frequency.NONE);
                        
                    } else if (p.equals(ParserFormats.ADD_TASK_ARGS_FORMAT_ON)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), matchOnDateTimeResult(matcher), 
                                null, Priority.DEFAULT_PRIORITY, 
                                Frequency.NONE);
                        
                    } else if (p.equals(ParserFormats.ADD_TASK_ARGS_FORMAT_BY)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), null,
                                matchByDateTimeResult(matcher), Priority.DEFAULT_PRIORITY, 
                                Frequency.NONE);
                        
                    } else if (p.equals(ParserFormats.ADD_TASK_ARGS_RECUR_FORMAT_FT)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), matchOnDateTimeResult(matcher), 
                                matchByDateTimeResult(matcher), Priority.DEFAULT_PRIORITY, 
                                Frequency.valueOf(matchRecurrenceResult(matcher).toUpperCase().trim()));
                        
                    } else if (p.equals(ParserFormats.ADD_TASK_ARGS_RECUR_FORMAT_BY)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), null, 
                                matchByDateTimeResult(matcher), Priority.DEFAULT_PRIORITY, 
                                Frequency.valueOf(matchRecurrenceResult(matcher).toUpperCase().trim()));
                        
                    } else if (p.equals(ParserFormats.ADD_TASK_ARGS_RECUR_FORMAT_ON)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), matchOnDateTimeResult(matcher), 
                                null, Priority.DEFAULT_PRIORITY, 
                                Frequency.valueOf(matchRecurrenceResult(matcher).toUpperCase().trim()));
                    
                    } else if (p.equals(ParserFormats.ADD_PRIORITY_FT)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), matchOnDateTimeResult(matcher), 
                                matchByDateTimeResult(matcher), matchPriorityResult(matcher), 
                                Frequency.NONE);
                         
                    } else if (p.equals(ParserFormats.ADD_PRIORITY_FL)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), null, 
                                null, matchPriorityResult(matcher), 
                                Frequency.NONE);
                        
                    } else if (p.equals(ParserFormats.ADD_PRIORITY_ON)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), matchOnDateTimeResult(matcher), 
                                null, matchPriorityResult(matcher), 
                                Frequency.NONE);  

                    } else if (p.equals(ParserFormats.ADD_PRIORITY_BY)) {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), null, 
                                matchByDateTimeResult(matcher), matchPriorityResult(matcher), 
                                Frequency.NONE);
                        
                    } else {
                        return new AddCommand(matchNameResult(matcher), 
                                matchDetailResult(matcher), 
                                null, null, 
                                Priority.DEFAULT_PRIORITY, Frequency.NONE);
                    }
                }
            }
        } catch (IllegalValueException ive) {
            return new IncorrectCommand(ive.getMessage());
        } catch (IllegalArgumentException iae) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
        }

        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, AddCommand.MESSAGE_USAGE));
    }

    /**
     * Parses arguments in the context of the delete task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareDelete(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, DeleteCommand.MESSAGE_USAGE));
        }

        return new DeleteCommand(index.get());
    }

    /**
     * Parses arguments in the context of the mark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareMark(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, MarkCommand.MESSAGE_USAGE));
        }

        return new MarkCommand(index.get());
    }

    /**
     * Parses arguments in the context of the unmark task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUnmark(String args) {

        Optional<Integer> index = parseIndex(args);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UnmarkCommand.MESSAGE_USAGE));
        }

        return new UnmarkCommand(index.get());
    }

    /**
     * Parses arguments in the context of the tag task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareTag(String args) {
        try {
            String tempArgs = args.trim();
            String indexString = tempArgs.split(" ")[0];

            Optional<Integer> index = parseIndex(indexString);
            if (!index.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
            }

            String tagNames = tempArgs.substring(indexString.length());

            return new TagCommand(index.get(), tagNames);
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, TagCommand.MESSAGE_USAGE));
        }

    }

    /**
     * Parses arguments in the context of the untag task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUntag(String args) {
        try {
            String tempArgs = args.trim();
            String indexString = tempArgs.substring(0, 1);

            Optional<Integer> index = parseIndex(indexString);
            if (!index.isPresent()) {
                return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UntagCommand.MESSAGE_USAGE));
            }

            String tagNames = tempArgs.substring(1);

            return new UntagCommand(index.get(), tagNames);
        } catch (Exception e) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UntagCommand.MESSAGE_USAGE));
        }

    }

    /**
     * Returns the specified index in the {@code command} IF a positive unsigned
     * integer is given as the index. Returns an {@code Optional.empty()}
     * otherwise.
     */
    private Optional<Integer> parseIndex(String command) {
        final Matcher matcher = ParserFormats.TASK_INDEX_ARGS_FORMAT.matcher(command.trim());
        if (!matcher.matches()) {
            return Optional.empty();
        }

        String index = matcher.group("targetIndex");
        if (!StringUtil.isUnsignedInteger(index)) {
            return Optional.empty();
        }
        return Optional.of(Integer.parseInt(index));

    }

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareUpdate(String args) {
        
        String tempArgs = args.trim(); 
        
        if (tempArgs.length() < 1) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }
        String indexString = tempArgs.split(" ")[0];

        Optional<Integer> index = parseIndex(indexString);
        if (!index.isPresent()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }

        tempArgs = tempArgs.substring(indexString.length()).trim();

        Matcher matcher;
        matcher = ParserFormats.UPDATE_TASK_ARGS_FORMAT.matcher(tempArgs.trim());
        if (matcher.matches()) {
            return new UpdateCommand(index.get(), 
                    matchNameResult(matcher).trim(), 
                    matchOnDateTimeResult(matcher), 
                    matchByDateTimeResult(matcher), 
                    matchDetailResult(matcher), 
                    matchPriorityResult(matcher), 
                    matchRecurrenceResult(matcher));
        } else {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, UpdateCommand.MESSAGE_USAGE));
        }  
        

    }
    
    /**
     * Parses arguments in the context of the search task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareSearch(String args) {
        Pattern[] dataPatterns = { ParserFormats.SEARCH_TASK_ARGS_FORMAT_ON,
                ParserFormats.SEARCH_TASK_ARGS_FORMAT_BEFORE, 
                ParserFormats.SEARCH_TASK_ARGS_FORMAT_AFTER,
                ParserFormats.SEARCH_TASK_ARGS_FORMAT_FT, 
                ParserFormats.SEARCH_KEYWORDS_ARGS_FORMAT,
                ParserFormats.SEARCH_TASK_ARGS_FORMAT_TAG,
                ParserFormats.SEARCH_PRIORITY };
        
        String tempArgs = args.trim(); 
       
        Matcher matcher;        
        for (Pattern p : dataPatterns) {
            matcher = p.matcher(tempArgs);
            
            if (matcher.matches()) {
                SearchCompletedOption option = SearchCompletedOption.UNDONE;
                if (matcher.group("comOpt") != null) {
                    option = SearchCompletedOption.valueOf(matcher.group(2).trim().toUpperCase());
                }                
                
                if (p.equals(ParserFormats.SEARCH_TASK_ARGS_FORMAT_ON)) {
                    return new SearchCommand(matchOnDateTimeResult(matcher),
                                             option,
                                             SearchCommand.SearchIndex.ON);
                    
                } else if (p.equals(ParserFormats.SEARCH_TASK_ARGS_FORMAT_BEFORE)) {
                    return new SearchCommand(matcher.group("beforeDateTime"),
                                             option,
                                             SearchCommand.SearchIndex.BEFORE);
                    
                } else if (p.equals(ParserFormats.SEARCH_TASK_ARGS_FORMAT_AFTER)) {
                    return new SearchCommand(matcher.group("afterDateTime"),
                                             option,
                                             SearchCommand.SearchIndex.AFTER);
                    
                } else if (p.equals(ParserFormats.SEARCH_TASK_ARGS_FORMAT_FT)) {
                    return new SearchCommand(matcher.group("fromDateTime") + SearchCommand.FT_CONCATENATER 
                                           + matcher.group("tillDateTime"),
                                             option,
                                             SearchCommand.SearchIndex.FT);
                    
                } else if (p.equals(ParserFormats.SEARCH_KEYWORDS_ARGS_FORMAT) 
                            && tempArgs.indexOf("tag") != ParserFormats.FIRST_INDEX
                            && tempArgs.indexOf("priority") != ParserFormats.FIRST_INDEX 
                            && tempArgs.indexOf("undone") != ParserFormats.FIRST_INDEX 
                            && tempArgs.indexOf("done") != ParserFormats.FIRST_INDEX) {
                    return new SearchCommand(matcher.group("keywords"), 
                                             option,
                                             SearchCommand.SearchIndex.KEYWORD);
                } else if (p.equals(ParserFormats.SEARCH_PRIORITY)) {
                    return new SearchCommand(matchPriorityResult(matcher), 
                                             option,
                                             SearchCommand.SearchIndex.PRIORITY);
                } else if (p.equals(ParserFormats.SEARCH_TASK_ARGS_FORMAT_TAG)) {
                    return new SearchCommand(matchTagsResult(matcher), 
                                             option,
                                             SearchCommand.SearchIndex.TAG);
                }
            }
        }
        

        if (tempArgs.indexOf("done") == ParserFormats.FIRST_INDEX) {
            return new SearchCommand(tempArgs, SearchCompletedOption.ALL, SearchCommand.SearchIndex.DONE);
        }

        if (tempArgs.indexOf("undone") == ParserFormats.FIRST_INDEX) {
            return new SearchCommand(tempArgs, SearchCompletedOption.ALL, SearchCommand.SearchIndex.UNDONE);
        }
        
        return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, SearchCommand.MESSAGE_USAGE));

    }
    
    /**
     * Parses arguments in the context of the store command.
     *
     * @param args full command args string
     * @return the prepared command
     */
    private Command prepareStore(String args) {
        args = args.trim();
        return new StoreCommand(args);
    }

}
```
###### \java\seedu\todo\model\DoDoBird.java
``` java
    @Override
    public UniqueTaskList getUniqueTaskList() {
        return this.tasksHistory.peek();
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tagsHistory.peek();
    }
```
###### \java\seedu\todo\model\DoDoBird.java
``` java
    public void resetData(Collection<? extends ReadOnlyTask> newTasks, Collection<Tag> newTags) {
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        setTags(newTags);
        
        for (Task t : this.getTasks()) {
            if (t.isRecurring() 
                    && (t.getOnDate().getDate().isBefore(LocalDate.now()) 
                    || t.getByDate().getDate().isBefore(LocalDate.now()))) {
                t.getRecurrence().updateTaskDate(t);
            }
        }
    }

    public void setTasks(List<Task> tasks) {
        if (this.tasksHistory.isEmpty()) {
            Collections.reverse(tasks);
            UniqueTaskList topList = this.copyTaskList(tasks);
            this.tasksHistory.push(topList);
        } else {
            this.updateTaskHistoryStack();
            this.getTasks().setAll(tasks);
        }
    }
    

    public void setTags(Collection<Tag> tags) {
        if (this.tagsHistory.isEmpty()) {
            UniqueTagList topList = this.copyTagList(tags);
            this.tagsHistory.push(topList);
        } else {
            this.updateTagHistoryStack();
            this.getTags().setAll(tags);
        }
        updateTagTopList();
    }

    /*************************
     * TASK-LEVEL OPERATIONS *
     *************************/
    
    public int getTaskIndex(ReadOnlyTask target) {
        return this.getTasks().indexOf(target);
    }
    
    public Task getTask(int index) {
        assert index >= 0;    
        return this.getTasks().get(index);
    }
    
    /**
     * Adds a task to the to do list.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws DuplicateTaskException {
        updateTaskHistoryStack();
        updateTagHistoryStack();

        try {
            this.getUniqueTaskList().add(p);
        } catch (DuplicateTaskException e) {
            undo();
            throw e;
        }
        
    }
    
    public void deleteTask(ReadOnlyTask key) throws TaskNotFoundException {
        updateTaskHistoryStack();
        updateTagHistoryStack();
        
        try {
            this.getUniqueTaskList().remove(key);
        } catch (TaskNotFoundException e) {
            undo();
            throw e;
        }
        updateTagTopList();

    }
    
    /**
     * Updates a task to the to do list.
     * 
     * @param index the index of the task to update
     * @param newTask copy the fields in new task into task to update
     * @throws UniqueTaskList.TaskNotFoundException if the task to update is not found.
     */
    public void updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) {
        updateTaskHistoryStack();
        updateTagHistoryStack();
         
        int index = this.getTaskIndex(oldTask);
            
        this.getTasks().get(index).setName(newTask.getName());
        this.getTasks().get(index).setDetail(newTask.getDetail());
        this.getTasks().get(index).setOnDate(newTask.getOnDate());
        this.getTasks().get(index).setByDate(newTask.getByDate());
        this.getTasks().get(index).setPriority(newTask.getPriority());
        this.getTasks().get(index).setRecurrence(newTask.getRecurrence());
        
    }
    
    public void addTaskTags(ReadOnlyTask oldTask, UniqueTagList newTagList) throws TaskNotFoundException {
        updateTaskHistoryStack();
        updateTagHistoryStack();
        
        int index = this.getTaskIndex(oldTask);
        Task toTag = this.getTasks().get(index); 
        for (Tag t : newTagList.getInternalList()) {
            try {
                if (this.getTags().contains(t)) {
                    Tag oldTag = this.getTags().get(this.getTags().indexOf(t));
                    toTag.addTag(oldTag);
                } else {
                    toTag.addTag(t);
                }    
            } catch (DuplicateTagException e) {
                //tag already added - do nothing
            }
        }
        updateTagTopList();
    }
    
    public void deleteTaskTags(ReadOnlyTask oldTask, UniqueTagList tagList) throws TaskNotFoundException {
        updateTaskHistoryStack();
        updateTagHistoryStack();
        
        int index = this.getTaskIndex(oldTask);
        Task toUntag = this.getTasks().get(index);
        
        for (Tag tag : tagList.getInternalList()) {
            try {
                toUntag.removeTag(tag);
            } catch (UniqueTagList.TagNotFoundException e) {
              //if not found just skip over - do nothing
            }
        }
        updateTagTopList();
    }
        
    /**
     * Pop the top most UniqueTaskList and UniqueTagList
     * Does not pop if there is only one state in history 
     * TODO : Does not handle tags as of yet
     */
    public boolean undo() {
        if (this.tasksHistory.size() > 1 && this.tagsHistory.size() > 1) {
            UniqueTaskList topTaskList = this.tasksHistory.pop();
            UniqueTaskList oldTaskList = this.tasksHistory.pop();
            topTaskList.getInternalList().setAll(oldTaskList.getInternalList());
            this.tasksHistory.push(topTaskList);
            
            UniqueTagList topTagList = this.tagsHistory.pop();
            UniqueTagList oldTagList = this.tagsHistory.pop();
            topTagList.getInternalList().setAll(oldTagList.getInternalList());
            this.tagsHistory.push(topTagList);
            
            updateTagTopList();
            return true;
        }
        return false;
    }
    
    
    /*************************
     *  TAG-LEVEL OPERATIONS *
     *************************/
    
    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        updateTagHistoryStack();
        UniqueTagList topList = this.getUniqueTagList();
        topList.add(t);
    }
    
    
    private void updateTagTopList() {
        UniqueTagList topList = this.getUniqueTagList();
        topList.getInternalList().clear();
        
        for (Task task : this.getTasks()) {
            for (Tag tag : task.getTags().getInternalList()) {
                try {
                    topList.add(tag);
                    tag.setCount(0);
                } catch (DuplicateTagException e) {
                    //if duplicate is encountered, do not add
                }
            }
        }
        
        for (Task task : this.getTasks()) {
            for (Tag tag : task.getTags().getInternalList()) {
                if (topList.contains(tag)) {
                    Tag inList = topList.getInternalList().get(topList.getInternalList().indexOf(tag));
                    inList.increaseCount();
                    if (inList != tag) {
                        tag.increaseCount();
                    }
                }
            }
        }
        
    }
    
    /******************
     *  UTIL METHODS  *
     ******************/
    
    @Override
    public String toString() {
        return tasksHistory.peek().getInternalList().size() + " tasks, " 
                + tagsHistory.peek().getInternalList().size() +  " tags";
        // TODO: refine later
    }
    
    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof DoDoBird // instanceof handles nulls
                && this.tasksHistory.peek().equals(((DoDoBird) other).tasksHistory.peek())
                && this.tagsHistory.peek().equals(((DoDoBird) other).tagsHistory.peek()));
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasksHistory.peek(), tagsHistory.peek());
    }
    
    /**
     * Updates tasks history
     * Maintains the reference of the top UniqueTaskList
     * Call this method for add, delete, update
     */
    private void updateTaskHistoryStack() {
        UniqueTaskList topList = this.tasksHistory.pop();
        UniqueTaskList oldList = this.copyTaskList(topList.getInternalList());
        this.tasksHistory.push(oldList);
        this.tasksHistory.push(topList);
    }
    
    /**
     * Updates tags history
     * Maintains the reference of the top UniqueTagList
     * Call this method for add, delete, update
     */
    private void updateTagHistoryStack() {
        UniqueTagList topList = this.tagsHistory.pop();
        UniqueTagList oldList = this.copyTagList(topList.getInternalList());
        this.tagsHistory.push(oldList);
        this.tagsHistory.push(topList);
        
    }
    
    private UniqueTaskList copyTaskList(List<Task> old) {
        UniqueTaskList newList = new UniqueTaskList();
                
        for (int i = old.size() - 1; i >= 0; i--) {
            try {
                newList.add(new Task(old.get(i)));
            } catch (UniqueTaskList.DuplicateTaskException e) {}
        }
        return newList;
    }
    
 
    private UniqueTagList copyTagList(Collection<Tag> old) {
        UniqueTagList newList = new UniqueTagList();
        
        for (Tag t : old) {
            try {
                newList.add(t);
            } catch (UniqueTagList.DuplicateTagException e) {}
        }
        return newList;
    }
    
}
```
###### \java\seedu\todo\model\Model.java
``` java
    /** Move model back to previous state */
    boolean undo();
    
    /** Add the given task */
    void addTask(Task task) throws UniqueTaskList.DuplicateTaskException;
    
    /** Deletes the given task. */
    void deleteTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;

    /** Retrieve the give task. */
    Task getTask(ReadOnlyTask target) throws UniqueTaskList.TaskNotFoundException;
    
    /** Update the given task */
    void updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) 
            throws UniqueTaskList.TaskNotFoundException;
    
    /** Add the given tags to the task*/
    void addTaskTags(ReadOnlyTask oldTask, UniqueTagList newTagList) 
            throws UniqueTaskList.TaskNotFoundException;
       
    /** Remove the given tags to the task*/
    void deleteTaskTags(ReadOnlyTask oldTask, UniqueTagList newTagList) 
            throws UniqueTaskList.TaskNotFoundException;
    
    /** Returns the filtered tasks list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList();

    /** Returns the filtered tasks list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredTodayTaskList();
    
    /** Returns the filtered tasks list as an {@code UnmodifiableObservableList<ReadOnlyTask>} */
    UnmodifiableObservableList<ReadOnlyTask> getFilteredWeekTaskList();
    
```
###### \java\seedu\todo\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show all tasks */
    void updateFilteredListToShowAll();
    
```
###### \java\seedu\todo\model\Model.java
``` java
    /** Updates the filter of the filtered task list to show all completed tasks */
    void updateFilteredListToShowAllCompleted();

    /** Updates the filter of the filtered task list to show all not completed tasks */
    void updateFilteredListToShowAllNotCompleted();
    
    /** Updates the filter of the filtered task list to filter by the given keywords*/
    void updateFilteredTaskListByKeywords(Set<String> keywords, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given tag name*/
    void updateFilteredTaskListByTag(String tagName, SearchCompletedOption option);

    /** Updates the filter of the filtered task list to filter by the given date*/
    void updateFilteredTaskListOnDate(LocalDateTime datetime, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given before date*/
    void updateFilteredTaskListBeforeDate(LocalDateTime datetime, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given after date*/
    void updateFilteredTaskListAfterDate(LocalDateTime datetime, SearchCompletedOption option);
    
    /** Updates the filter of the filtered task list to filter by the given from and till dates*/
    void updateFilteredTaskListFromTillDate(LocalDateTime fromDateTime, LocalDateTime tillDateTime, 
            SearchCompletedOption option);
```
###### \java\seedu\todo\model\ModelManager.java
``` java
    @Override
    public synchronized Task getTask(ReadOnlyTask target) {
        return dodobird.getTask(dodobird.getTaskIndex(target));
    }
    
    @Override
    public synchronized void updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) throws TaskNotFoundException {
        dodobird.updateTask(oldTask, newTask);
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized void addTaskTags(ReadOnlyTask oldTask, UniqueTagList newTagList) throws TaskNotFoundException {
        dodobird.addTaskTags(oldTask, newTagList);
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized void deleteTaskTags(ReadOnlyTask oldTask, UniqueTagList newTagList) 
            throws TaskNotFoundException {
        dodobird.deleteTaskTags(oldTask, newTagList);
        indicateToDoListChanged();
    }
    
    //=========== Filtered Task List Accessors ===============================================================
    
```
###### \java\seedu\todo\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }
    
```
###### \java\seedu\todo\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true))); //force change
        filteredTasks.setPredicate(null);
    }
    
    @Override
    public void updateFilteredListToShowAllCompleted(){
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true)));
    }
    
    @Override
    public void updateFilteredListToShowAllNotCompleted(){
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(false)));
    }

    @Override
    public void updateFilteredTaskListByKeywords(Set<String> keywords, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new KeywordQualifier(keywords, option)));
    }

    @Override
    public void updateFilteredTaskListByTag(String tagName, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new TagQualifier(tagName, option)));
    }
    
    @Override
    public void updateFilteredTaskListOnDate(LocalDateTime datetime, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new OnDateQualifier(datetime, option)));
    }
    
    @Override
    public void updateFilteredTaskListBeforeDate(LocalDateTime datetime, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new BeforeDateQualifier(datetime, option)));
    }

    @Override
    public void updateFilteredTaskListAfterDate(LocalDateTime datetime, SearchCompletedOption option) {
        updateFilteredTaskList(new PredicateExpression(new AfterDateQualifier(datetime, option)));
    }
    
    @Override
    public void updateFilteredTaskListFromTillDate(LocalDateTime fromDateTime, LocalDateTime tillDateTime, 
            SearchCompletedOption option){
        updateFilteredTaskList(new PredicateExpression(new FromTillDateQualifier(fromDateTime, tillDateTime, option)));
    }

```
###### \java\seedu\todo\model\qualifiers\AfterDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.logic.commands.SearchCommand.SearchCompletedOption;
import seedu.todo.model.task.ReadOnlyTask;

/**
 *  A qualifier that filters tasks if they are to be done after
 * a certain datetime
 */
public class AfterDateQualifier implements Qualifier {
  
    private LocalDateTime datetime;
    private SearchCompletedOption option;
    
    public AfterDateQualifier(LocalDateTime datetime, SearchCompletedOption option) {
        this.datetime = datetime;
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate onDate = task.getOnDate().getDate(); 
        LocalTime onTime = task.getOnDate().getTime();
        
        LocalDate byDate = task.getByDate().getDate(); 
        LocalTime byTime = task.getByDate().getTime();
        
        boolean onAfter = false;
        boolean byAfter = false;
        
        if (onDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(onDate, onTime);
            onAfter = onDateTime.isAfter(datetime);
        }
        
        if (byDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(byDate, byTime);
            byAfter = onDateTime.isAfter(datetime);
        }
        
        boolean taskIsAfter = onAfter || byAfter; //true if either the starting date or ending is after
        
        if (option == SearchCompletedOption.ALL) {
            return taskIsAfter;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsAfter && task.getCompletion().isCompleted();
        } else {
            return taskIsAfter && !task.getCompletion().isCompleted();
        }
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### \java\seedu\todo\model\qualifiers\BeforeDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.logic.commands.SearchCommand.SearchCompletedOption;
import seedu.todo.model.task.ReadOnlyTask;

/**
 * A qualifier that filters tasks if they are to be done before
 * a certain datetime
 */
public class BeforeDateQualifier implements Qualifier {
   
    private LocalDateTime datetime;
    private SearchCompletedOption option;
    
    public BeforeDateQualifier(LocalDateTime datetime, SearchCompletedOption option) {
        this.datetime = datetime;
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate onDate = task.getOnDate().getDate(); 
        LocalTime onTime = task.getOnDate().getTime();
        
        LocalDate byDate = task.getByDate().getDate(); 
        LocalTime byTime = task.getByDate().getTime();
        
        boolean onBefore = false;
        boolean byBefore = false;
        
        if (onDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(onDate, onTime);
            onBefore = onDateTime.isBefore(datetime);
        }
        
        if (byDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(byDate, byTime);
            byBefore = onDateTime.isBefore(datetime);
        }
        
        boolean taskIsBefore = onBefore || byBefore; //true if either the starting date or ending is after
        
        if (option == SearchCompletedOption.ALL) {
            return taskIsBefore;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsBefore && task.getCompletion().isCompleted();
        } else {
            return taskIsBefore && !task.getCompletion().isCompleted();
        }
            
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### \java\seedu\todo\model\qualifiers\CompletedQualifier.java
``` java
package seedu.todo.model.qualifiers;

import seedu.todo.model.task.ReadOnlyTask;

/**
 * A qualifier that filter tasks depending on whether the task
 * is completed or not.
 */
public class CompletedQualifier implements Qualifier {
    
    private boolean wantsDone;
    
    public CompletedQualifier(boolean wantsDone){
        this.wantsDone = wantsDone;
    }
    
    @Override
    public boolean run(ReadOnlyTask task) {
        return this.wantsDone ? task.getCompletion().isCompleted() : !task.getCompletion().isCompleted();
    }

    @Override
    public String toString() {
        return this.wantsDone ? "done" : "not done";
    }
}
```
###### \java\seedu\todo\model\qualifiers\FromTillDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.logic.commands.SearchCommand.SearchCompletedOption;
import seedu.todo.model.task.ReadOnlyTask;

/**
 * A qualifier that filter tasks depending on the tasks starting 
 * and ending date.
 */
public class FromTillDateQualifier implements Qualifier{
  
    private LocalDateTime fromDateTime;
    private LocalDateTime tillDateTime;
    private SearchCompletedOption option;
    
    public FromTillDateQualifier(LocalDateTime fromDateTime, LocalDateTime tillDateTime, 
            SearchCompletedOption option) {
        this.fromDateTime = fromDateTime;
        this.tillDateTime = tillDateTime;
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate fromDate = task.getOnDate().getDate(); 
        LocalTime fromTime = task.getOnDate().getTime();
        
        LocalDate tillDate = task.getByDate().getDate(); 
        LocalTime tillTime = task.getByDate().getTime();
        
        boolean onFrom = false;
        boolean byTill = false;
        
        if (fromDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(fromDate, fromTime);
            onFrom = onDateTime.isAfter(fromDateTime);
        }
        
        if (tillDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(tillDate, tillTime);
            byTill = onDateTime.isBefore(tillDateTime);
        }
        
       
        boolean taskIsFromTill = onFrom && byTill; //must be in between the both dates
        
        if (option == SearchCompletedOption.ALL) {
            return taskIsFromTill;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsFromTill && task.getCompletion().isCompleted();
        } else {
            return taskIsFromTill && !task.getCompletion().isCompleted();
        }
            
    }

    @Override
    public String toString() {
        return "datetime=" + fromDateTime.toString() + " " + tillDateTime.toString();
    }
}
```
###### \java\seedu\todo\model\qualifiers\OnDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDateTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.logic.commands.SearchCommand.SearchCompletedOption;
import seedu.todo.model.task.ReadOnlyTask;

/**
 * A qualifier that filter tasks based on whether their
 * starting date is on a certain date.
 */
public class OnDateQualifier implements Qualifier {
    
    private LocalDateTime datetime;
    private SearchCompletedOption option;
    
    public OnDateQualifier(LocalDateTime datetime, SearchCompletedOption option) {
        this.datetime = datetime;
        this.option = option;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        boolean taskIsOnDate;
        
        if (task.getOnDate().getDate() != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(task.getOnDate().getDate(), 
                    task.getOnDate().getTime());
            taskIsOnDate = onDateTime.toLocalDate().equals(datetime.toLocalDate());
        } else {
            taskIsOnDate = false;
        }
        
        
        if (option == SearchCompletedOption.ALL) {
            return taskIsOnDate;
        } else if (option == SearchCompletedOption.DONE) {
            return taskIsOnDate && task.getCompletion().isCompleted();
        } else {
            return taskIsOnDate && !task.getCompletion().isCompleted();
        }
        
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### \java\seedu\todo\model\task\Completion.java
``` java
package seedu.todo.model.task;

/**
 * Represents a Task's completion.
 */
public class Completion {

    private boolean isCompleted;
    
    public Completion() {
        this(false);
    }
    
    public Completion(boolean completed) {
        this.isCompleted = completed;
    }
    
    public boolean isCompleted() {
        return this.isCompleted;
    }
    
    public void setCompletion(boolean completed) {
        this.isCompleted = completed;
    }
    
    public void toggle() {
        this.isCompleted = !this.isCompleted;
    }
    
    @Override
    public String toString() {
        return isCompleted ? "true" : "false";
    }
    
}
```
###### \java\seedu\todo\model\task\Detail.java
``` java
package seedu.todo.model.task;


/**
 * Represents a Task's details in the to do application. 
 * Guarantees: mutable; no constraints.
 */
public class Detail {

    public static final String MESSAGE_DETAILS_CONSTRAINTS = "Task details has no constraint.";

    public String value;

    public Detail(String detail) {
        if (detail == null) {
            detail = "";
        }
        detail = detail.trim();
        this.value = detail;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Detail // instanceof handles nulls
                        && this.value.equals(((Detail) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\todo\model\task\Name.java
``` java
package seedu.todo.model.task;

import seedu.todo.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's name in the to do list.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Name {

    public static final String MESSAGE_NAME_CONSTRAINTS = "Task names should be spaces or alphanumeric characters";
    public static final String NAME_VALIDATION_REGEX = "[^;]+";
    public static final String ESCAPE = "'";
    public static final int MAX_CHAR_LENGTH = 120;
    
    public final String fullName;

    /**
     * Validates given name.
     *
     * @throws IllegalValueException if given name string is invalid.
     */
    public Name(String name) throws IllegalValueException {
        assert name != null;
        String tempName = name.trim().replace(ESCAPE, "");
        if (!isValidName(tempName)) {
            throw new IllegalValueException(MESSAGE_NAME_CONSTRAINTS);
        }
        this.fullName = tempName;
    }

    /**
     * Returns true if a given string is a valid task name.
     */
    public static boolean isValidName(String test) {
        return test.matches(NAME_VALIDATION_REGEX) && test.length() <= MAX_CHAR_LENGTH;
    }


    @Override
    public String toString() {
        return fullName;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Name // instanceof handles nulls
                && this.fullName.equals(((Name) other).fullName)); // state check
    }

    @Override
    public int hashCode() {
        return fullName.hashCode();
    }

}
```
###### \java\seedu\todo\model\task\ReadOnlyTask.java
``` java
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || ((other != null) // this is first to avoid NPE below
                && other.getName().equals(this.getName())
                && other.getDetail().equals(this.getDetail())
                && other.getPriority().equals(this.getPriority())
                && other.getOnDate().equals(this.getOnDate())
                && other.getByDate().equals(this.getByDate()));
    }

    /**
     * Formats the task as text, showing all task information.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName() + "\n")
                .append("Details: ")
                .append(getDetail() + "\n")
                .append("From: ")
                .append(getOnDate() + "\n")
                .append("Till: ")
                .append(getByDate() + "\n")
                .append("Tags: ");
        //getTags().forEach(builder::append);
        return builder.toString();
    }

    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }

}
```
###### \java\seedu\todo\model\task\Recurrence.java
``` java
package seedu.todo.model.task;

import seedu.todo.commons.exceptions.IllegalValueException;

/**
 * Represents a Task's name in the to do list.
 * Guarantees: immutable; is valid as declared in {@link #isValidName(String)}
 */
public class Recurrence {
    
    public enum Frequency {
        NONE,
        YEAR,
        MONTH,
        WEEK,
        DAY
    }
    
    private Frequency freq;
    
    public Recurrence(Frequency freq) throws IllegalValueException {
        assert freq != null;
        this.freq = freq;
    }
    
    public Frequency getFreq() {
        return this.freq;
    }
    
    public void setFreq(Frequency freq) {
        this.freq = freq;
    }
        
    public boolean isRecurring() {
        return this.freq != Frequency.NONE;
    }
    
    @Override
    public String toString() {
        switch(this.freq) {
        case YEAR :
            return "YEAR";
        case MONTH :
            return "MONTH";
        case WEEK:
            return "WEEK";
        case DAY :
            return "DAY";
        default :
            return "NONE";
        }
    }
    
    /**
     * Update the dates for a task based on the recurrence of the task.
     * Will mark the task as undone as well.
     */
    public void updateTaskDate(Task task){
        task.getCompletion().setCompletion(false);
        switch(this.freq) {
        case YEAR :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusYears(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusYears(1));
            }
            break;
        case MONTH :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusMonths(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusMonths(1));
            }
            break;
        case WEEK:
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusWeeks(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusWeeks(1));
            }
            break;
        case DAY :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusDays(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusDays(1));
            }
            break;
        default :
            //Default value is NONE - do not need to update
        }
    }
    
}
```
###### \java\seedu\todo\model\task\Task.java
``` java
package seedu.todo.model.task;

import java.util.Objects;

import seedu.todo.commons.util.CollectionUtil;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList;

/**
 * Represents a Task in DoDo-Bird
 * Guarantees: all fields are not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private Detail detail;
    private TaskDate onDate;
    private TaskDate byDate; //deadline
    private Priority priority;
    private Completion completion;
    private UniqueTagList tags;
    private Recurrence recurrence;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, Detail detail, TaskDate fromDate, 
            TaskDate tillDate, Priority priority, Recurrence recurrence) {
        
        assert !CollectionUtil.isAnyNull(name, detail, fromDate, tillDate, recurrence);
        
        this.name = name;
        this.detail = detail;
        this.onDate = fromDate;
        this.byDate = tillDate;
        this.priority = priority;
        this.recurrence = recurrence;
        this.completion = new Completion(false);
        this.tags = new UniqueTagList(); // protect internal tags from changes in the arg list
    }
    
    public Task(Name name, Detail detail, Completion completion, TaskDate fromDate, 
            TaskDate tillDate, Priority priority, Recurrence recurrence, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, detail, fromDate, tillDate, completion, recurrence);
        this.name = name;
        this.detail = detail;
        this.onDate = fromDate;
        this.byDate = tillDate;
        this.priority = priority;
        this.completion = completion;
        this.recurrence = recurrence;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
    
    /**
     * Copy constructor.
     */
    public Task(ReadOnlyTask source) {
        this(source.getName(), source.getDetail(), source.getCompletion(), source.getOnDate(), 
                source.getByDate(), source.getPriority(), source.getRecurrence(), source.getTags());
    }

    @Override
    public Name getName() {
        return this.name;
    }

    @Override
    public Detail getDetail() {
        return this.detail;
    }

    @Override
    public TaskDate getOnDate() {
        return this.onDate;
    }

    @Override
    public TaskDate getByDate() {
        return this.byDate;
    }

    @Override
    public UniqueTagList getTags() {
        return new UniqueTagList(tags);
    }
    
    @Override
    public Completion getCompletion() {
        return this.completion;
    }
    
    @Override
    public Recurrence getRecurrence() {
        return this.recurrence;
    }
```
###### \java\seedu\todo\model\task\Task.java
``` java
    @Override
    public boolean isRecurring() {
        return this.recurrence.isRecurring();
    }
    
    public void setName(Name n) {
        this.name = n;
    }

    public void setDetail(Detail d) {
        this.detail = d;
    }

    public void setOnDate(TaskDate fd) {
        this.onDate = fd;
    }

    public void setByDate(TaskDate td) {
        this.byDate = td;
    }
```
###### \java\seedu\todo\model\task\Task.java
``` java
    public void setCompletion(Completion c) {
        this.completion = c;
    }
    
    public void setRecurrence(Recurrence r) {
        this.recurrence = r;
    }
    
    /**
     * Add a tag to the task's tag list 
     */
    public void addTag(Tag toAdd) throws UniqueTagList.DuplicateTagException {
        tags.add(toAdd);
    }
    
    /**
     * Remove a tag to the task's tag list 
     */
    public void removeTag(Tag toRemove) throws UniqueTagList.TagNotFoundException{
        tags.remove(toRemove);
    }
    
    /**
     * Replaces this task's tags with the tags in the argument tag list.
     */
    public void setTags(UniqueTagList replacement) {
        tags.setTags(replacement);
    }
```
###### \java\seedu\todo\model\task\TaskDate.java
``` java
package seedu.todo.model.task;


import java.time.LocalTime;

import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.DateTimeUtil;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Represents the information for Task's date and time .
 * 
 * Guarantees: valid as long as natty can parse it. The parsing is done in using DateTimeUtil.
 */
public class TaskDate {

    public static final String MESSAGE_DATETIME_CONSTRAINTS = "Tasks' dates and time need to follow predefined format.";
    
    public static final String TASK_DATE_ON = "START";
    public static final String TASK_DATE_BY = "END";
    
    private LocalDate date;
    private LocalTime time;
    
    /**
     * Validates given date and time string.
     *
     * @throws IllegalValueException if given date and time string is invalid.
     */
    public TaskDate(String dateTimeString, String onOrBy) throws IllegalValueException {
        
        assert onOrBy != null;
        
        if (DateTimeUtil.isEmptyDateTimeString(dateTimeString)) {
            this.date = null;
            this.time = null;
        } else {
            LocalDateTime ldt = DateTimeUtil.parseDateTimeString(dateTimeString, onOrBy);
            if (ldt == null) {
                throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
            } else {
                this.date = ldt.toLocalDate();
                this.time = ldt.toLocalTime();
            }  
        }
    }

    public LocalDate getDate() {
        return this.date;
    }
    
    public LocalTime getTime() {
        return this.time;
    }
    
    public LocalDate setDate(LocalDate date) {
        return this.date = date;
    }
    
    public LocalTime setTime(LocalTime time) {
        return this.time = time;
    }

    @Override
    public String toString() {
        String dateString;
        String timeString;
        
        if (date == null) {
            dateString = "";
        } else {
            dateString = DateTimeUtil.prettyPrintDate(date);
        }
        
        if (time == null) {
            timeString = "";
        } else {
            timeString = DateTimeUtil.prettyPrintTime(time);
        }

        return dateString + " " + timeString;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && ((this.date == null && ((TaskDate) other).date == null)
                || ((this.date != null && ((TaskDate) other).date != null)
                && DateTimeUtil.combineLocalDateAndTime(this.date, this.time)
                    .equals(DateTimeUtil.combineLocalDateAndTime(((TaskDate) other).date, ((TaskDate) other).time)))));
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

}
```
###### \java\seedu\todo\storage\XmlAdaptedTag.java
``` java
package seedu.todo.storage;

import javax.xml.bind.annotation.XmlElement;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.model.tag.Tag;

/**
 * JAXB-friendly adapted version of the Tag.
 */
public class XmlAdaptedTag {

    @XmlElement(required = true)
    public String tagName;
    
    @XmlElement
    public String taskCount;

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTag() {}

    /**
     * Converts a given Tag into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created
     */
    public XmlAdaptedTag(Tag source) {
        tagName = source.getName();
        taskCount = source.getCount() + "";
    }

    /**
     * Converts this jaxb-friendly adapted tag object into the model's Tag object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Tag toModelType() throws IllegalValueException {
        return new Tag(tagName, Integer.parseInt(taskCount));
    }

}
```
###### \java\seedu\todo\storage\XmlAdaptedTask.java
``` java
package seedu.todo.storage;

import javax.xml.bind.annotation.XmlElement;

import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList;
import seedu.todo.model.task.*;
import seedu.todo.model.task.Recurrence.Frequency;

import java.util.ArrayList;
import java.util.List;

/**
 * JAXB-friendly version of the Task.
 */
public class XmlAdaptedTask {

    @XmlElement(required = true)
    private String name;
    @XmlElement
    private String detail;
    @XmlElement
    private String onDate;
    @XmlElement
    private String byDate;
    @XmlElement
    private String priority;
    @XmlElement
    private String completion;
    @XmlElement
    private String recurrence;
    @XmlElement
    private List<XmlAdaptedTag> tagged = new ArrayList<>();

    /**
     * No-arg constructor for JAXB use.
     */
    public XmlAdaptedTask() {}


    /**
     * Converts a given Task into this class for JAXB use.
     *
     * @param source future changes to this will not affect the created XmlAdaptedTask
     */
    public XmlAdaptedTask(ReadOnlyTask source) {
        name = source.getName().fullName;
        detail = source.getDetail().toString();
        completion = source.getCompletion().toString();
        onDate = source.getOnDate().toString();
        byDate = source.getByDate().toString();
        priority = source.getPriority().toString();
        recurrence = source.getRecurrence().toString();
        tagged = new ArrayList<>();
        
        for (Tag tag : source.getTags()) {
            tagged.add(new XmlAdaptedTag(tag));
        }
        
    }

    /**
     * Converts this jaxb-friendly adapted task object into the model's Task object.
     *
     * @throws IllegalValueException if there were any data constraints violated in the adapted task
     */
    public Task toModelType() throws IllegalValueException {
        final List<Tag> taskTags = new ArrayList<>();
        
        for (XmlAdaptedTag tag : tagged) {
            taskTags.add(tag.toModelType());
        }
       
        final Name name = new Name(this.name);
        final Detail detail = new Detail(this.detail);
        final Completion completion = new Completion(Boolean.parseBoolean(this.completion));
        final TaskDate onDate = new TaskDate(this.onDate, TaskDate.TASK_DATE_ON);
        final TaskDate byDate = new TaskDate(this.byDate, TaskDate.TASK_DATE_BY);
        final Priority priority = new Priority(this.priority);
        final Recurrence recurrence = new Recurrence(Frequency.valueOf(this.recurrence));
        final UniqueTagList tags = new UniqueTagList(taskTags);
        return new Task(name, detail, completion, onDate, byDate, priority, recurrence, tags);
    }
}
```
###### \java\seedu\todo\storage\XmlSerializableToDoList.java
``` java
    /**
     * Conversion
     */
    public XmlSerializableToDoList(ReadOnlyToDoList src) {
        tasks.addAll(src.getTaskList().stream().map(XmlAdaptedTask::new).collect(Collectors.toList()));
        tags.addAll(src.getTagList().stream().map(XmlAdaptedTag::new).collect(Collectors.toList()));
    }
```
###### \java\seedu\todo\storage\XmlSerializableToDoList.java
``` java
    @Override
    public List<Tag> getTagList() {
        return tags.stream().map(t -> {
            try {
                return t.toModelType();
            } catch (IllegalValueException e) {
                e.printStackTrace();
                //TODO: better error handling
                return null;
            }
        }).collect(Collectors.toCollection(ArrayList::new));
    }

}
```
###### \java\seedu\todo\ui\CommandBox.java
``` java
    private Stack<String> commandHistory = new Stack<>();
    private Stack<String> commandFuture = new Stack<>();
```
###### \java\seedu\todo\ui\CommandBox.java
``` java
    @FXML
    private void handleKeyPressed(KeyEvent e) {
        if (e.getCode().toString().equals("UP") && !commandHistory.isEmpty()) {
            String c = commandHistory.pop();
            commandFuture.push(c);
            commandTextField.setText(c);
        }
        if (e.getCode().toString().equals("DOWN") && !commandFuture.isEmpty()) {
            String c = commandFuture.pop();
            commandHistory.push(c);
            commandTextField.setText(c);
        }
    }
```
###### \java\seedu\todo\ui\PrettifyDate.java
``` java
package seedu.todo.ui;

import java.time.LocalDate;
import java.time.format.DateTimeFormatter;
import java.time.temporal.ChronoUnit;

public class PrettifyDate {

    public static final int THRESHOLD = 3;
    
    /**
     * Prettify the date for UI printing.
     */
    public static String prettifyDate(LocalDate date) {
        LocalDate today = LocalDate.now();
        
        if (date.equals(today)) {
            return "Today";
        }
        if (date.plusDays(1).equals(today)) {
            return "Yesterday";
        }
        if (date.minusDays(1).equals(today)) {
            return "Tomorrow";
        }
        
        if (date.isBefore(today) && today.minusDays(THRESHOLD).isBefore(date)) {
            int diff = Math.abs((int) ChronoUnit.DAYS.between(today, date));
            return diff + " days ago";
        } else if (date.isAfter(today) && today.plusDays(THRESHOLD).isAfter(date)) {
            int diff = Math.abs((int) ChronoUnit.DAYS.between(today, date));
            return diff + " days later";
        }
        
        return date.format(DateTimeFormatter.ofPattern("dd-MMM-YY"));
        
    }
     
    
}
```
