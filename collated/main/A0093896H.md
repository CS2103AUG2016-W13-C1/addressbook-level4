# A0093896H
###### \java\seedu\todo\commons\core\Config.java
``` java
    public static final String DEFAULT_CONFIG_FILE = "defaultConfig.json";
```
###### \java\seedu\todo\commons\util\DateTimeUtil.java
``` java
package seedu.todo.commons.util;

import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.Map;
import java.time.LocalDateTime;

import com.joestelmach.natty.*;

import seedu.todo.model.task.TaskDate;

/**
 * Helper functions for anything with regards to date and time.
 */
public class DateTimeUtil {

    public static boolean isEmptyDateTimeString(String dateTimeString) {
        return (dateTimeString == null || dateTimeString.equals("") || dateTimeString.equals(" "));
    }

    /**
     * Attempts to parse a String into LocalDateTime.
     * 
     * If the String does not contains date information, the default date used is the current date.
     * 
     * If the String does not contains time information, the default time used is the 0000hrs if
     * it is an onDate and 2359 if it is a byDate.
     * 
     * @param dateTimeString
     * @param onOrBy
     * @return LocalDateTime
     */
    public static LocalDateTime parseDateTimeString(String dateTimeString, String onOrBy) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);

        if (groups.size() == 0) {
            return null;
        } else {
            DateGroup group = groups.get(0);
            Map<String, List<ParseLocation>> m = group.getParseLocations();

            Date date = group.getDates().get(0);
            Calendar c = Calendar.getInstance();
            c.setTime(date);
            
            LocalDateTime ldt;
            if (!m.keySet().contains("date")) {
                ldt = LocalDateTime.now();
                ldt = LocalDateTime.of(ldt.getYear(), ldt.getMonth(), ldt.getDayOfMonth(), 
                        c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE));
            } else {
                if (!m.keySet().contains("explicit_time")) {
                    if (onOrBy.equals(TaskDate.TASK_DATE_BY)) {
                        ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                                c.get(Calendar.DATE), 23, 59);
                    } else {
                        ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                                c.get(Calendar.DATE), 00, 00);
                    }
                } else {
                    ldt = LocalDateTime.of(c.get(Calendar.YEAR), c.get(Calendar.MONTH) + 1, 
                            c.get(Calendar.DATE), c.get(Calendar.HOUR_OF_DAY), c.get(Calendar.MINUTE));
                }
                
            }
            
            return ldt;
        }
    }

    /**
     * Checks whether date information is able to be parsed out 
     * from a String
     * 
     * @param dateTimeString
     * @return boolean
     */
    public static boolean containsDateField(String dateTimeString) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);
        
        if (groups.size() == 0) {
            return false;
        } else {
            DateGroup group = groups.get(0);
            Map<String, List<ParseLocation>> m = group.getParseLocations();
            return m.keySet().contains("date");
        }
    }
    
    /**
     * Checks whether time information is able to be parsed out 
     * from a String
     * 
     * @param dateTimeString
     * @return boolean
     */
    public static boolean containsTimeField(String dateTimeString) {
        Parser nattyParser = new Parser();
        List<DateGroup> groups = nattyParser.parse(dateTimeString);
        
        if (groups.size() == 0) {
            return false;
        } else {
            DateGroup group = groups.get(0);
            Map<String, List<ParseLocation>> m = group.getParseLocations();
            return m.keySet().contains("explicit_time");
        }
    }
    
    
    public static LocalDateTime combineLocalDateAndTime(LocalDate date, LocalTime time) {
        assert date != null;
        if (time == null) {
            return LocalDateTime.of(date.getYear(), date.getMonth(), date.getDayOfMonth(), 23, 59);
        } else {
            return LocalDateTime.of(date, time);
        }
    }
    
    
    public static String prettyPrintDate(LocalDate date) {
        return date.format(DateTimeFormatter.ofPattern("dd MMM yyyy"));
    }

    public static String prettyPrintTime(LocalTime time) {
        return time.format(DateTimeFormatter.ofPattern("hh:mm a"));
    }

}
```
###### \java\seedu\todo\logic\commands\AddCommand.java
``` java
package seedu.todo.logic.commands;

import java.time.LocalDate;

import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.*;
import seedu.todo.model.task.Recurrence.Frequency;

/**
 * Adds a person to the address book.
 */
public class AddCommand extends Command {

    public static final String COMMAND_WORD = "add";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Adds a task to the to do list. "
            + "Parameters: TASKNAME on STARTDATE by ENDDATE ; DETAILS...\n"
            + "Example: " + COMMAND_WORD
            + " get groceries on 10/10/2016 by 11/10/2016 ; bread, fruits, cinnamon powder, red pepper";

    public static final String MESSAGE_SUCCESS = "New task added! Name : %1$s";
    public static final String MESSAGE_DUPLICATE_TASK = "This task already exists in the to do list";

    private final Task toAdd;
    
    /**
     * Convenience constructor using raw values.
     *
     * @throws IllegalValueException if any of the raw values are invalid
     */
    public AddCommand(String name, String detail, String onDateString, String byDateString, String priority, Frequency freq)
            throws IllegalValueException {
        
        TaskDate onDate = new TaskDate(onDateString, TaskDate.TASK_DATE_ON);
        TaskDate byDate = new TaskDate(byDateString, TaskDate.TASK_DATE_BY);
        if (byDate.getDate() != null && !DateTimeUtil.containsDateField(byDateString)) {
            
            byDate.setDate(LocalDate.of(onDate.getDate().getYear(), 
                    onDate.getDate().getMonth(), onDate.getDate().getDayOfMonth()));
        }
        this.toAdd = new Task(
                new Name(name),
                new Detail(detail),
                onDate,
                byDate,
                new Priority(priority),
                new Recurrence(freq)
        );
    }

    @Override
    public CommandResult execute() {
        assert model != null;
        try {
            model.addTask(toAdd);
            model.updateFilteredListToShowAll();
            return new CommandResult(String.format(MESSAGE_SUCCESS, toAdd.getName()));
        } catch (UniqueTaskList.DuplicateTaskException e) {
            return new CommandResult(MESSAGE_DUPLICATE_TASK);
        }

    }

}
```
###### \java\seedu\todo\logic\commands\DeleteCommand.java
``` java
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getUnmodifiableFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToDelete = lastShownList.get(targetIndex - 1);

        try {
            model.deleteTask(taskToDelete);
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be missing";
        }

        return new CommandResult(String.format(MESSAGE_DELETE_TASK_SUCCESS, taskToDelete.getName()));
    }

}
```
###### \java\seedu\todo\logic\commands\MarkCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.task.Completion;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;
import seedu.todo.model.tag.UniqueTagList.DuplicateTagException;

public class MarkCommand extends Command {

    public static final String COMMAND_WORD = "mark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Marks the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Mark Task: Name : %1$s";

    public final int targetIndex;

    public MarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getUnmodifiableFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
        
        try {
            Task toMark = model.getTask(taskToMark);
            
            toMark.setCompletion(new Completion(true));
            toMark.addTag(new Tag("done"));
            
            model.updateTask(taskToMark, toMark);
            model.updateTaskTags(taskToMark, toMark);
            model.updateFilteredListToShowAll();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be found";
        } catch (DuplicateTagException e) {
            assert false : "The tag is already added";
        } catch (IllegalValueException e) {
            assert false : "The tag name is not valid";
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToMark.getName()));
    }
}
```
###### \java\seedu\todo\logic\commands\ResetCommand.java
``` java
package seedu.todo.logic.commands;

import java.io.IOException;
import java.util.Optional;

import seedu.todo.commons.core.Config;
import seedu.todo.commons.exceptions.DataConversionException;
import seedu.todo.commons.util.ConfigUtil;

/**
 * Reset Config to default
 */
public class ResetCommand extends Command {

    public static final String COMMAND_WORD = "reset";

    public static final String MESSAGE_SUCCESS = "Reset User Config !";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Reset the user config to default"
            + "Example: " + COMMAND_WORD;
    
    public static final String MESSAGE_SAVE_ERROR = "Unable to save config to new location.";
    
    public ResetCommand() {}
    
    @Override
    public CommandResult execute() {
        
        String configFilePathUsed = Config.DEFAULT_CONFIG_FILE;
        
        Config initializedConfig;
        try {
            Optional<Config> configOptional = ConfigUtil.readConfig(configFilePathUsed);
            initializedConfig = configOptional.orElse(new Config());
        } catch (DataConversionException e) {
            initializedConfig = new Config();
        } 
        
        try {
            ConfigUtil.saveConfig(initializedConfig, Config.USER_CONFIG_FILE);
            return new CommandResult(MESSAGE_SUCCESS);
        } catch (IOException e) {
            return new CommandResult(MESSAGE_SAVE_ERROR);
        }
          
    }
        
   
}
```
###### \java\seedu\todo\logic\commands\SearchCommand.java
``` java
package seedu.todo.logic.commands;

import java.time.LocalDateTime;
import java.time.format.DateTimeParseException;
import java.util.Arrays;
import java.util.HashSet;
import java.util.Set;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.Priority;
import seedu.todo.model.task.TaskDate;

/**
 * Finds and lists all persons in address book whose name contains any of the argument keywords.
 * Keyword matching is case sensitive.
 */
public class SearchCommand extends Command {

    public static final String COMMAND_WORD = "search";

    public static final String MESSAGE_USAGE = COMMAND_WORD + ": Search all tasks whose names contain any of "
            + "the specified keywords and displays them as a list with index numbers.\n"
            + "Parameters: KEYWORD [MORE_KEYWORDS]...\n"
            + "Example: " + COMMAND_WORD + " birthday homework friday";

    private final String data;
    private final int whichSearch;
    
    public SearchCommand(String data, int whichSearch) {
        this.data = data;
        this.whichSearch = whichSearch;
    }

    @Override
    public CommandResult execute() {
        switch (whichSearch) {
        case 0 : //on date search
            try {
                LocalDateTime datetime = DateTimeUtil.parseDateTimeString(data, TaskDate.TASK_DATE_ON);
                model.updateFilteredTaskListOnDate(datetime);
                return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
            } catch (DateTimeParseException e) {
                return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
            }
        case 1 : //before date search
            try {
                LocalDateTime datetime = DateTimeUtil.parseDateTimeString(data, TaskDate.TASK_DATE_BY);
                model.updateFilteredTaskListBeforeDate(datetime);
                    
                return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
                    
            } catch (DateTimeParseException e) {
                return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
            }
                
        case 2 : //after date search
            try {
                LocalDateTime datetime = DateTimeUtil.parseDateTimeString(data, TaskDate.TASK_DATE_ON);
                model.updateFilteredTaskListAfterDate(datetime);
                    
                return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
                    
            } catch (DateTimeParseException e) {
                return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
            }
                
        case 3 : //from till date search
            try {
                String fromDateString = data.split("@")[0].trim();
                LocalDateTime fromDateTime = DateTimeUtil.parseDateTimeString(fromDateString, TaskDate.TASK_DATE_ON);
                    
                String tillDateString = data.split("@")[1].trim();
                LocalDateTime tillDateTime = DateTimeUtil.parseDateTimeString(tillDateString, TaskDate.TASK_DATE_BY);
                    
                model.updateFilteredTaskListFromTillDate(fromDateTime, tillDateTime);
                return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
                    
            } catch (DateTimeParseException e) {
                return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
            }
                
        case 4 : //keyword search
            final String[] keywords = data.split("\\s+");
            final Set<String> keywordSet = new HashSet<>(Arrays.asList(keywords));
            model.updateFilteredTaskListByKeywords(keywordSet);
            return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
                
        case 5 : //tag search
            String tag = data.split("tag")[1].trim();
            model.updateFilteredTaskListByTag(tag);
            return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
                
        case 6 : //done search
            model.updateFilteredListToShowAllCompleted();
            return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
                
        case 7 : //undone search
            model.updateFilteredListToShowAllNotCompleted();
            return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));

        case 8 : //priority search
            try {
            	String priority = data.trim();                   
                model.updateFilteredTaskListByPriority(new Priority(priority));
                return new CommandResult(getMessageForTaskListShownSummary(model.getUnmodifiableFilteredTaskList().size()));
                    
            } catch (IllegalValueException e) {
                return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
            }
                
        default :
            return new CommandResult(Messages.MESSAGE_INVALID_COMMAND_FORMAT);
        }
        
        
        
        ///
        
        
        
    }

}
```
###### \java\seedu\todo\logic\commands\StoreCommand.java
``` java
package seedu.todo.logic.commands;

import java.io.IOException;

import seedu.todo.commons.core.Config;
import seedu.todo.commons.util.ConfigUtil;
import seedu.todo.commons.util.FileUtil;


/**
 * Change data storage location
 */
public class StoreCommand extends Command {

    public static final String COMMAND_WORD = "store";

    public static final String MESSAGE_SUCCESS = "Change storage location !";
    
    public static final String MESSAGE_SAVE_ERROR = "Unable to save to new location.";
    
    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Changes the storage location to the location specified by the user. "
            + "Parameters: NEW_STORAGE_LOCATION\n"
            + "Example: " + COMMAND_WORD + "data/dodobird.xml";

    private final String location;
    
    public StoreCommand(String newLocation) {
        this.location = newLocation;
    }
    
    @Override
    public CommandResult execute() {
        String defaultLocation = config.getToDoListFilePath();
        String tempLocation = this.location + "/" + config.getToDoListName() + ".xml";
        
        if (FileUtil.isFilenameValid(tempLocation)) {
            try {
                config.setToDoListFilePath(tempLocation);
                ConfigUtil.saveConfig(config, Config.USER_CONFIG_FILE);
                storage.setToDoListFilePath(tempLocation);
                storage.saveToDoList(model.getToDoList());
                return new CommandResult(MESSAGE_SUCCESS);
            } catch (IOException e){
                config.setToDoListFilePath(defaultLocation);
                storage.setToDoListFilePath(defaultLocation);
                return new CommandResult(MESSAGE_SAVE_ERROR);
            }
        } else {
            return new CommandResult(MESSAGE_SAVE_ERROR);
        }
          
    }
        
   
}
```
###### \java\seedu\todo\logic\commands\TagCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList;
import seedu.todo.model.tag.UniqueTagList.DuplicateTagException;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Tags a task identified using it's last displayed index from the to do list.
 * with tags
 */
public class TagCommand extends Command{

    public static final String COMMAND_WORD = "tag";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Tags the task identified by the index number used in the last task listing. "
            + "Tag name must be unique\n"
            + "Parameters: INDEX TAGNAME [MORE TAGNAMES]\n"
            + "Example: " + COMMAND_WORD + " 1 birthday clique";

    public static final String MESSAGE_SUCCESS = "Tagged Task: Name : %1$s";

    public final int targetIndex;
    public final UniqueTagList tags;
    
    public TagCommand(int targetIndex, String tagNames) throws Exception {

        this.targetIndex = targetIndex;
        
        if (tagNames.isEmpty()) {
            throw new Exception();
        }
        
        tags = new UniqueTagList();
        for (String tagName : tagNames.trim().split(" ")) {
            tags.add(new Tag(tagName));
        }
        
    }
    
    
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getUnmodifiableFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToTag = lastShownList.get(targetIndex - 1);

        try {
            Task toTag = model.getTask(taskToTag);
            
            for (Tag tag : tags) {
                try {
                    toTag.addTag(tag);
                } catch (DuplicateTagException e) {}
            }
            model.updateTaskTags(taskToTag, toTag);
            model.updateFilteredListToShowAll();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be found";
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToTag.getName()));
    }
    
    
    
}
```
###### \java\seedu\todo\logic\commands\UndoCommand.java
``` java
package seedu.todo.logic.commands;

public class UndoCommand extends Command {

    public static final String COMMAND_WORD = "undo";

    public static final String MESSAGE_SUCCESS = "Undo the previous command";
    public static final String MESSAGE_NO_PREVIOUS_STATE = "There is no previous state to return to.";

    public UndoCommand() {}

    @Override
    public CommandResult execute() {
        if (model.undo()) {
            return new CommandResult(MESSAGE_SUCCESS);
        } else {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(MESSAGE_NO_PREVIOUS_STATE);
        }

    }
}
```
###### \java\seedu\todo\logic\commands\UnmarkCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList.TagNotFoundException;
import seedu.todo.model.task.Completion;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

public class UnmarkCommand extends Command {
    
    public static final String COMMAND_WORD = "unmark";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Unmarks the task identified by the index number used in the last task listing.\n"
            + "Parameters: INDEX (must be a positive integer)\n"
            + "Example: " + COMMAND_WORD + " 1";

    public static final String MESSAGE_SUCCESS = "Unmark Task: %1$s";

    public final int targetIndex;

    public UnmarkCommand(int targetIndex) {
        this.targetIndex = targetIndex;
    }

    @Override
    public CommandResult execute() {
        
        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getUnmodifiableFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToMark = lastShownList.get(targetIndex - 1);
        
        try {
            Task toMark = model.getTask(taskToMark);
            
            toMark.setCompletion(new Completion(false));
            toMark.removeTag(new Tag("done"));
            
            model.updateTask(taskToMark, toMark);
            model.updateTaskTags(taskToMark, toMark);
            model.updateFilteredListToShowAll();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be found";
        } catch (TagNotFoundException e) {
            assert false : "The tag cannot be found";
        } catch (IllegalValueException e) {
            assert false : "The tag name is not valid";
        }
        
        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToMark.getName()));
    }
}
```
###### \java\seedu\todo\logic\commands\UntagCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Tags a task identified using it's last displayed index from the to do list.
 * with tags
 */
public class UntagCommand extends Command{

    public static final String COMMAND_WORD = "untag";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Untags the task identified by the index number used in the last task listing. "
            + "Tag names must be unique\n"
            + "Parameters: INDEX TAGNAME [MORE TAGNAMES]\n"
            + "Example: " + COMMAND_WORD + " 1 birthday clique";

    public static final String MESSAGE_SUCCESS = "Untagged Task: %1$s";

    public final int targetIndex;
    public final UniqueTagList tags;
    
    public UntagCommand(int targetIndex, String tagNames) throws Exception {

        this.targetIndex = targetIndex;
        
        if (tagNames.isEmpty()) {
            throw new Exception();
        }
        
        tags = new UniqueTagList();
        for (String tagName : tagNames.trim().split(" ")) {
            tags.add(new Tag(tagName));
        }
        
    }
    
    
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getUnmodifiableFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUntag = lastShownList.get(targetIndex - 1);

        try {
            Task toUntag = model.getTask(taskToUntag);
            
            for (Tag tag : tags) {
                try {
                    toUntag.removeTag(tag);
                } catch (UniqueTagList.TagNotFoundException e) {}
            }
            model.updateTaskTags(taskToUntag, toUntag);
            model.updateFilteredListToShowAll();
        } catch (TaskNotFoundException pnfe) {
            assert false : "The target task cannot be found";
        }

        return new CommandResult(String.format(MESSAGE_SUCCESS, taskToUntag.getName()));
    }
    
    
    
}
```
###### \java\seedu\todo\logic\commands\UpdateCommand.java
``` java
package seedu.todo.logic.commands;

import seedu.todo.commons.core.Messages;
import seedu.todo.commons.core.UnmodifiableObservableList;
import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.model.task.Detail;
import seedu.todo.model.task.Name;
import seedu.todo.model.task.Priority;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.Recurrence;
import seedu.todo.model.task.Recurrence.Frequency;
import seedu.todo.model.task.Task;
import seedu.todo.model.task.TaskDate;
import seedu.todo.model.task.UniqueTaskList.TaskNotFoundException;

/**
 * Update a task identified using it's last displayed index from the to do list.
 */
public class UpdateCommand extends Command{

    public static final String COMMAND_WORD = "update";

    public static final String MESSAGE_USAGE = COMMAND_WORD
            + ": Update the task identified by the index number used in the last task listing. \n"
            + "Prefix a - sign in front of optional fields you wished to remove.\n"
            + "Parameters: ID [NEW_NAME] [[-]on DATE [tTime]] [[-]by DATE [tTime]] [[-]; a line of new details]\n"
            + "Example: " + COMMAND_WORD + " 2 on 14/10/2017 by 18/10/2017 ";

    public static final String MESSAGE_UPDATE_TASK_SUCCESS = "Update Task: %1$s";

    private final int targetIndex;
    
    private final String name;
    private final String detail;
    private final String onDateTime;
    private final String byDateTime;
    private final String priority;
    private final String recurrence;
    
    public UpdateCommand(int targetIndex, String name, String onDateTime, 
            String byDateTime, String detail, String priority, String recurrence) {
        this.targetIndex = targetIndex;
        this.name = name;
        this.detail = detail;
        this.onDateTime = onDateTime;
        this.byDateTime = byDateTime;
        this.priority = priority;
        this.recurrence = recurrence;
    }
    
    
    @Override
    public CommandResult execute() {

        UnmodifiableObservableList<ReadOnlyTask> lastShownList = model.getUnmodifiableFilteredTaskList();

        if (lastShownList.size() < targetIndex) {
            indicateAttemptToExecuteIncorrectCommand();
            return new CommandResult(Messages.MESSAGE_INVALID_TASK_DISPLAYED_INDEX);
        }

        ReadOnlyTask taskToUpdate = lastShownList.get(targetIndex - 1);
        
        try {            
            Name newName = this.makeNewName(taskToUpdate);
            Detail newDetail = this.makeNewDetail(taskToUpdate);
            TaskDate newByDate = this.makeNewByDate(taskToUpdate);
            TaskDate newOnDate = this.makeNewOnDate(taskToUpdate);
            Priority newPriority = this.makeNewPriority(taskToUpdate);
            Recurrence newRecurrence = this.makeNewRecurrence(taskToUpdate);
            
            Task newTask = new Task(newName, newDetail, taskToUpdate.getCompletion(), 
                    newOnDate, newByDate, newPriority, newRecurrence, taskToUpdate.getTags());
            
            model.updateTask(taskToUpdate, newTask);
            model.updateFilteredListToShowAll();
            
            return new CommandResult(String.format(MESSAGE_UPDATE_TASK_SUCCESS, newTask));
            
        } catch (TaskNotFoundException pnfe) {
            return new CommandResult(MESSAGE_USAGE);
        
        } catch (IllegalValueException e) {
            return new CommandResult(MESSAGE_USAGE);
        }
        
    }
    
    private Name makeNewName(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        return this.name.equals("") ? taskToUpdate.getName() : new Name(this.name);
    }
    
    private Detail makeNewDetail(ReadOnlyTask taskToUpdate) {
        Detail newDetail;
        if (this.detail == null) {
            newDetail = taskToUpdate.getDetail();
        } else {
            newDetail = this.detail.trim().equals("-") 
                    ?  new Detail(null) 
                    : new Detail(this.detail);
        }
        return newDetail;
    }
    
    private TaskDate makeNewByDate(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        TaskDate newByDate;
        if (this.byDateTime == null) {
            newByDate = taskToUpdate.getByDate();
        } else {
            newByDate = this.byDateTime.trim().equals("-") 
                    ?  new TaskDate("", TaskDate.TASK_DATE_BY) 
                    : new TaskDate(this.byDateTime, TaskDate.TASK_DATE_BY);
        }
        return newByDate;
    }
    
    private TaskDate makeNewOnDate(ReadOnlyTask taskToUpdate) throws IllegalValueException {
        TaskDate newOnDate;
        if (this.onDateTime == null) {
            newOnDate = taskToUpdate.getOnDate();
        } else {
            newOnDate = this.onDateTime.trim().equals("-") 
                    ?  new TaskDate("", TaskDate.TASK_DATE_ON) 
                    : new TaskDate(this.onDateTime, TaskDate.TASK_DATE_ON);
        }
        return newOnDate;
    }
```
###### \java\seedu\todo\logic\parser\ParserFormats.java
``` java
package seedu.todo.logic.parser;

import java.util.regex.Pattern;


/**
 * Contains the various regex Patterns that ToDoListParser will use 
 * for the different commands.
 */
public class ParserFormats {
    
    public static final String priorityFormat = " priority (?<priority>[^;]+)";
    public static final String ON_DATE_FORMAT = " (on|from) (?<onDateTime>[^;]+)" ;
    public static final String BY_DATE_FORMAT = " (by|to) (?<byDateTime>[^;]+)";
    public static final String DETAIL_FORMAT = "(?: ?; ?(?<detail>.+))?";
    public static final String NAME_FORMAT = "(?<name>[^/;]+)";
    public static final String RECUR_FORMAT = " every (?<rec>[^;]+)";
            
    /**
     * Used for initial separation of command word and args.
     */
    public static final Pattern BASIC_COMMAND_FORMAT = Pattern.compile("(?<commandWord>\\S+)(?<arguments>.*)");

    public static final Pattern TASK_INDEX_ARGS_FORMAT = Pattern.compile("(?<targetIndex>.+)");
    
    //one or more keywords separated by whitespace
    public static final Pattern KEYWORDS_ARGS_FORMAT = Pattern.compile("(?<keywords>\\S+(?:\\s+\\S+)*)"); 
    
    public static final Pattern ADD_TASK_ARGS_FORMAT_FT = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + BY_DATE_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_FORMAT_ON = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_FORMAT_BY = Pattern
            .compile(NAME_FORMAT + BY_DATE_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_FORMAT_FLOAT = Pattern
            .compile(NAME_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);
    
    public static final Pattern ADD_TASK_ARGS_RECUR_FORMAT_FT = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + BY_DATE_FORMAT + RECUR_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_RECUR_FORMAT_ON = Pattern
            .compile(NAME_FORMAT + ON_DATE_FORMAT + RECUR_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);

    public static final Pattern ADD_TASK_ARGS_RECUR_FORMAT_BY = Pattern
            .compile(NAME_FORMAT + BY_DATE_FORMAT + RECUR_FORMAT + DETAIL_FORMAT, Pattern.CASE_INSENSITIVE);
```
###### \java\seedu\todo\logic\parser\ToDoListParser.java
``` java
    /**
     * Parses user input into command for execution.
     *
     * @param userInput full user input string
     * @return the command based on the user input
     */
    public Command parseCommand(String userInput) {
        final Matcher matcher = ParserFormats.BASIC_COMMAND_FORMAT.matcher(userInput.trim());
        if (!matcher.matches()) {
            return new IncorrectCommand(String.format(MESSAGE_INVALID_COMMAND_FORMAT, HelpCommand.MESSAGE_USAGE));
        }

        final String commandWord = matcher.group("commandWord");
        final String arguments = matcher.group("arguments");
        switch (commandWord) {

        case AddCommand.COMMAND_WORD:
            return prepareAdd(arguments);

        case ClearCommand.COMMAND_WORD:
            return new ClearCommand();

        case DeleteCommand.COMMAND_WORD:
            return prepareDelete(arguments);

        case ExitCommand.COMMAND_WORD:
            return new ExitCommand();

        case HelpCommand.COMMAND_WORD:
            return new HelpCommand();

        case MarkCommand.COMMAND_WORD:
            return prepareMark(arguments);

        case SearchCommand.COMMAND_WORD:
            return prepareSearch(arguments);

        case SeeCommand.COMMAND_WORD:
            return new SeeCommand();

        case TagCommand.COMMAND_WORD:
            return prepareTag(arguments);

        case UntagCommand.COMMAND_WORD:
            return prepareUntag(arguments);

        case UnmarkCommand.COMMAND_WORD:
            return prepareUnmark(arguments);

        case UndoCommand.COMMAND_WORD:
            return new UndoCommand();

        case UpdateCommand.COMMAND_WORD:
            return prepareUpdate(arguments);
            
        case StoreCommand.COMMAND_WORD:
            return prepareStore(arguments);
            
        case ResetCommand.COMMAND_WORD:
            return new ResetCommand();


        default:
            return new IncorrectCommand(MESSAGE_UNKNOWN_COMMAND);
        }
    }
    
    private String matchNameResult(Matcher matcher) {
    	return matcher.group("name");
    }
    
    private String matchDetailResult(Matcher matcher) {
    	return matcher.group("detail");
    }
    
    private String matchOnDateTimeResult(Matcher matcher) {
    	return matcher.group("onDateTime");
    }
    
    private String matchByDateTimeResult(Matcher matcher) {
    	return matcher.group("byDateTime");
    }
    
    private String matchPriorityResult(Matcher matcher) {
    	return matcher.group("priority");
    }
    
    private String matchRecurrenceResult(Matcher matcher) {
    	return matcher.group("rec");
    }
    

    /**
     * Parses arguments in the context of the add task command.
     *
     * @param args full command args string
     * @return the prepared command
     */
```
###### \java\seedu\todo\model\ModelManager.java
``` java
    public ModelManager(ReadOnlyToDoList initialData, UserPrefs userPrefs) {
        toDoList = new ToDoList(initialData);
        filteredTasks = new FilteredList<>(toDoList.getTasks());
        todayTasks = new FilteredList<>(toDoList.getTasks());
        tagList = new FilteredList<>(toDoList.getTags());
        updateTodayListToShowAll();
    }

    @Override
    public void resetData(ReadOnlyToDoList newData) {
        toDoList.resetData(newData);
        indicateToDoListChanged();
    }
    
    @Override
    public boolean undo() {
        if (toDoList.undo()) {
            indicateToDoListChanged();
            return true;
        }
        return false;
    }

    @Override
    public ReadOnlyToDoList getToDoList() {
        return toDoList;
    }

    /** Raises an event to indicate the model has changed */
    public void indicateToDoListChanged() {
        raise(new ToDoListChangedEvent(toDoList));
    }

    @Override
    public synchronized void deleteTask(ReadOnlyTask target) throws TaskNotFoundException {
        toDoList.removeTask(target);
        indicateToDoListChanged();
    }

    @Override
    public synchronized void addTask(Task task) throws UniqueTaskList.DuplicateTaskException {
        toDoList.addTask(task);
        indicateToDoListChanged();
    }
    
```
###### \java\seedu\todo\model\ModelManager.java
``` java
    @Override
    public synchronized Task getTask(ReadOnlyTask target) throws TaskNotFoundException {
        int index = toDoList.getTasks().indexOf(target);
        
        if (index < 0) {
            throw new TaskNotFoundException();
        } else {
            return toDoList.getTasks().get(index);
        }
    }
    
    @Override
    public synchronized void updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) throws TaskNotFoundException {
        toDoList.updateTask(oldTask, newTask);
        indicateToDoListChanged();
    }
    
    @Override
    public synchronized void updateTaskTags(ReadOnlyTask oldTask, ReadOnlyTask newTask) throws TaskNotFoundException {
        int index = toDoList.getTasks().indexOf(oldTask);
        
        if (index < 0) {
            throw new TaskNotFoundException();
        } else {
            toDoList.getTasks().get(index).setTags(newTask.getTags());
            indicateToDoListChanged();
        }
        
        toDoList.updateTaskTags(oldTask, newTask);
    }
```
###### \java\seedu\todo\model\ModelManager.java
``` java
    @Override
    public UnmodifiableObservableList<ReadOnlyTask> getUnmodifiableFilteredTaskList() {
        return new UnmodifiableObservableList<>(filteredTasks);
    }
    
```
###### \java\seedu\todo\model\ModelManager.java
``` java
    @Override
    public void updateFilteredListToShowAll() {
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true))); //force change
        filteredTasks.setPredicate(null);
    }
    
    @Override
    public void updateFilteredListToShowAllCompleted(){
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(true)));
    }
    
    @Override
    public void updateFilteredListToShowAllNotCompleted(){
        updateFilteredTaskList(new PredicateExpression(new CompletedQualifier(false)));
    }

    @Override
    public void updateFilteredTaskListByKeywords(Set<String> keywords){
        updateFilteredTaskList(new PredicateExpression(new NameQualifier(keywords)));
    }

    @Override
    public void updateFilteredTaskListByTag(String tagName){
        updateFilteredTaskList(new PredicateExpression(new TagQualifier(tagName)));
    }
    
    @Override
    public void updateFilteredTaskListOnDate(LocalDateTime datetime){
        updateFilteredTaskList(new PredicateExpression(new OnDateQualifier(datetime)));
    }
    
    @Override
    public void updateFilteredTaskListBeforeDate(LocalDateTime datetime){
        updateFilteredTaskList(new PredicateExpression(new BeforeDateQualifier(datetime)));
    }

    @Override
    public void updateFilteredTaskListAfterDate(LocalDateTime datetime){
        updateFilteredTaskList(new PredicateExpression(new AfterDateQualifier(datetime)));
    }
    
    @Override
    public void updateFilteredTaskListFromTillDate(LocalDateTime fromDateTime, LocalDateTime tillDateTime){
        updateFilteredTaskList(new PredicateExpression(new FromTillDateQualifier(fromDateTime, tillDateTime)));
    }

```
###### \java\seedu\todo\model\qualifiers\AfterDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.ReadOnlyTask;

public class AfterDateQualifier implements Qualifier{
    private LocalDateTime datetime;

    public AfterDateQualifier(LocalDateTime datetime) {
        this.datetime = datetime;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate onDate = task.getOnDate().getDate(); 
        LocalTime onTime = task.getOnDate().getTime();
        
        LocalDate byDate = task.getByDate().getDate(); 
        LocalTime byTime = task.getByDate().getTime();
        
        boolean onAfter = false;
        boolean byAfter = false;
        
        if (onDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(onDate, onTime);
            onAfter = onDateTime.isAfter(datetime);
        }
        
        if (byDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(byDate, byTime);
            byAfter = onDateTime.isAfter(datetime);
        }
        
        return onAfter || byAfter;
            
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### \java\seedu\todo\model\qualifiers\BeforeDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.TaskDate;

public class BeforeDateQualifier implements Qualifier{
    private LocalDateTime datetime;

    public BeforeDateQualifier(LocalDateTime datetime) {
        this.datetime = datetime;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate onDate = task.getOnDate().getDate(); 
        LocalTime onTime = task.getOnDate().getTime();
        
        LocalDate byDate = task.getByDate().getDate(); 
        LocalTime byTime = task.getByDate().getTime();
        
        boolean onBefore = false;
        boolean byBefore = false;
        
        if (onDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(onDate, onTime);
            onBefore = onDateTime.isBefore(datetime);
        }
        
        if (byDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(byDate, byTime);
            byBefore = onDateTime.isBefore(datetime);
        }
        
        return onBefore || byBefore;
            
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### \java\seedu\todo\model\qualifiers\CompletedQualifier.java
``` java
package seedu.todo.model.qualifiers;

import seedu.todo.model.task.ReadOnlyTask;

public class CompletedQualifier implements Qualifier{
    private boolean wantsDone;
    
    public CompletedQualifier(boolean wantsDone){
        this.wantsDone = wantsDone;
    }
    
    @Override
    public boolean run(ReadOnlyTask task) {
        return this.wantsDone ? task.getCompletion().isCompleted() : !task.getCompletion().isCompleted();
    }

    @Override
    public String toString() {
        return this.wantsDone ? "done" : "not done";
    }
}
```
###### \java\seedu\todo\model\qualifiers\FromTillDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.ReadOnlyTask;
import seedu.todo.model.task.TaskDate;

public class FromTillDateQualifier implements Qualifier{
    private LocalDateTime fromDateTime;
    private LocalDateTime tillDateTime;

    public FromTillDateQualifier(LocalDateTime fromDateTime, LocalDateTime tillDateTime) {
        this.fromDateTime = fromDateTime;
        this.tillDateTime = tillDateTime;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        LocalDate fromDate = task.getOnDate().getDate(); 
        LocalTime fromTime = task.getOnDate().getTime();
        
        LocalDate tillDate = task.getByDate().getDate(); 
        LocalTime tillTime = task.getByDate().getTime();
        
        boolean onFrom = false;
        boolean byTill = false;
        
        if (fromDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(fromDate, fromTime);
            onFrom = onDateTime.isAfter(fromDateTime);
        }
        
        if (tillDate != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(tillDate, tillTime);
            byTill = onDateTime.isBefore(tillDateTime);
        }
        
        return onFrom && byTill;
            
    }

    @Override
    public String toString() {
        return "datetime=" + fromDateTime.toString() + " " + tillDateTime.toString();
    }
}
```
###### \java\seedu\todo\model\qualifiers\OnDateQualifier.java
``` java
package seedu.todo.model.qualifiers;

import java.time.LocalDateTime;

import seedu.todo.commons.util.DateTimeUtil;
import seedu.todo.model.task.ReadOnlyTask;

public class OnDateQualifier implements Qualifier{
    private LocalDateTime datetime;

    public OnDateQualifier(LocalDateTime datetime) {
        this.datetime = datetime;
    }

    @Override
    public boolean run(ReadOnlyTask task) {
        if (task.getOnDate().getDate() != null) {
            LocalDateTime onDateTime = DateTimeUtil.combineLocalDateAndTime(task.getOnDate().getDate(), 
                    task.getOnDate().getTime());
            return onDateTime.toLocalDate().equals(datetime.toLocalDate());
        } else {
            return false;
        }
        
    }

    @Override
    public String toString() {
        return "datetime=" + datetime.toString();
    }
}
```
###### \java\seedu\todo\model\task\Completion.java
``` java
package seedu.todo.model.task;

public class Completion {

    private boolean completed;
    
    public Completion() {
        this(false);
    }
    
    public Completion(boolean completed) {
        this.completed = completed;
    }
    
    public boolean isCompleted() {
        return this.completed;
    }
    
    public void setCompletion(boolean completed) {
        this.completed = completed;
    }
    
    public void toggle() {
        this.completed = !this.completed;
    }
    
    @Override
    public String toString() {
        return completed ? "true" : "false";
    }
    
}
```
###### \java\seedu\todo\model\task\Detail.java
``` java
package seedu.todo.model.task;


/**
 * Represents a Task's details in the to do application. Guarantees: mutable; no
 * constraints.
 */
public class Detail {

    public static final String MESSAGE_DETAILS_CONSTRAINTS = "Task details has no constraint.";

    public String value;

    public Detail(String detail) {
        if (detail == null) {
            detail = "";
        }
        detail = detail.trim();
        this.value = detail;
    }

    @Override
    public String toString() {
        return value;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof Detail // instanceof handles nulls
                        && this.value.equals(((Detail) other).value)); // state check
    }

    @Override
    public int hashCode() {
        return value.hashCode();
    }

}
```
###### \java\seedu\todo\model\task\ReadOnlyTask.java
``` java
    default boolean isSameStateAs(ReadOnlyTask other) {
        return other == this // short circuit if same object
                || ((other != null) // this is first to avoid NPE below
                && other.getName().equals(this.getName())
                && other.getDetail().equals(this.getDetail())
                && other.getPriority().equals(this.getPriority())
                && (other.getOnDate().equals(this.getOnDate())
                && other.getByDate().equals(this.getByDate())));
    }

    /**
     * Formats the task as text, showing all task information.
     */
    default String getAsText() {
        final StringBuilder builder = new StringBuilder();
        builder.append(getName() + "\n")
                .append("Details: ")
                .append(getDetail() + "\n")
                .append("From: ")
                .append(getOnDate() + "\n")
                .append("Till: ")
                .append(getByDate() + "\n")
                .append("Tags: ");
        //getTags().forEach(builder::append);
        return builder.toString();
    }

    /**
     * Returns a string representation of this Task's tags
     */
    default String tagsString() {
        final StringBuffer buffer = new StringBuffer();
        final String separator = ", ";
        getTags().forEach(tag -> buffer.append(tag).append(separator));
        if (buffer.length() == 0) {
            return "";
        } else {
            return buffer.substring(0, buffer.length() - separator.length());
        }
    }

}
```
###### \java\seedu\todo\model\task\Recurrence.java
``` java
package seedu.todo.model.task;

import seedu.todo.commons.exceptions.IllegalValueException;

public class Recurrence {
    
    public enum Frequency {
        NONE,
        YEAR,
        MONTH,
        WEEK,
        DAY
    }
    
    private Frequency freq;
    
    public Recurrence(Frequency freq) throws IllegalValueException {
        assert freq != null;
        this.freq = freq;
    }
    
    public Frequency getFreq() {
        return this.freq;
    }
    
    public void setFreq(Frequency freq) {
        this.freq = freq;
    }
        
    public boolean isRecurring() {
       return this.freq != Frequency.NONE;
    }
    
    @Override
    public String toString() {
        switch(this.freq) {
            case YEAR :
                return "YEAR";
            case MONTH :
                return "MONTH";
            case WEEK:
                return "WEEK";
            case DAY :
                return "DAY";
            default :
                return "NONE";
        }
    }
    
    public void updateTaskDate(Task task){
        switch(this.freq) {
        case YEAR :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusYears(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusYears(1));
            }
            break;
        case MONTH :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusMonths(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusMonths(1));
            }
            break;
        case WEEK:
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusWeeks(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusWeeks(1));
            }
            break;
        case DAY :
            if (task.getOnDate().getDate() != null) {
                task.getOnDate().setDate(task.getOnDate().getDate().plusDays(1));
            }
            if (task.getByDate().getDate() != null) {
                task.getByDate().setDate(task.getByDate().getDate().plusDays(1));
            }
            break;
        default :
            //NONE - do nothing
        }
    }
    
}
```
###### \java\seedu\todo\model\task\Task.java
``` java
package seedu.todo.model.task;

import java.util.Objects;

import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.CollectionUtil;
import seedu.todo.model.tag.Tag;
import seedu.todo.model.tag.UniqueTagList;

/**
 * Represents a Task in DoDo-Bird
 * Guarantees: all fields are not null, field values are validated.
 */
public class Task implements ReadOnlyTask {

    private Name name;
    private Detail detail;
    private TaskDate onDate;
    private TaskDate byDate; //deadline
    private Priority priority;
    private Completion completion;
    private UniqueTagList tags;
    private Recurrence recurrence;

    /**
     * Every field must be present and not null.
     */
    public Task(Name name, Detail detail, TaskDate fromDate, TaskDate tillDate, Priority priority, Recurrence recurrence) {
        assert !CollectionUtil.isAnyNull(name, detail, fromDate, tillDate, recurrence);
        this.name = name;
        this.detail = detail;
        this.onDate = fromDate;
        this.byDate = tillDate;
        this.priority = priority;
        this.recurrence = recurrence;
        this.completion = new Completion(false);
        this.tags = new UniqueTagList(); // protect internal tags from changes in the arg list
    }
    
    public Task(Name name, Detail detail, Completion completion, TaskDate fromDate, 
            TaskDate tillDate, Priority priority, Recurrence recurrence, UniqueTagList tags) {
        assert !CollectionUtil.isAnyNull(name, detail, fromDate, tillDate, completion, recurrence);
        this.name = name;
        this.detail = detail;
        this.onDate = fromDate;
        this.byDate = tillDate;
        this.priority = priority;
        this.completion = completion;
        this.recurrence = recurrence;
        this.tags = new UniqueTagList(tags); // protect internal tags from changes in the arg list
    }
```
###### \java\seedu\todo\model\task\TaskDate.java
``` java
package seedu.todo.model.task;


import java.time.LocalTime;

import seedu.todo.commons.exceptions.IllegalValueException;
import seedu.todo.commons.util.CollectionUtil;
import seedu.todo.commons.util.DateTimeUtil;

import java.time.LocalDate;
import java.time.LocalDateTime;

/**
 * Represents a Task's from and till date.
 * Guarantees: mutable; is valid as declared in {@link #isValidPhone(String)}
 */
public class TaskDate {

    public static final String MESSAGE_DATETIME_CONSTRAINTS = "Tasks' dates and time need to follow predefined format.";
    
    public static final String TASK_DATE_ON = "START";
    public static final String TASK_DATE_BY = "END";
    
    private LocalDate date;
    private LocalTime time;
    
    /**
     * Validates given date and time string.
     *
     * @throws IllegalValueException if given date and time string is invalid.
     */
    public TaskDate(String dateTimeString, String onOrBy) throws IllegalValueException {
        
        assert onOrBy != null;
        
        if (DateTimeUtil.isEmptyDateTimeString(dateTimeString)) {
            this.date = null;
            this.time = null;
        } else {
            LocalDateTime ldt = DateTimeUtil.parseDateTimeString(dateTimeString, onOrBy);
            if (ldt == null) {
                throw new IllegalValueException(MESSAGE_DATETIME_CONSTRAINTS);
            } else {
                this.date = ldt.toLocalDate();
                this.time = ldt.toLocalTime();
            }  
        }
    }

    public TaskDate(LocalDateTime ldt) {
        assert ldt != null;
        this.date = ldt.toLocalDate();
        this.time = ldt.toLocalTime();
    }
    
    public TaskDate(LocalDate date, LocalTime time) {
        assert !CollectionUtil.isAnyNull(date, time);
        this.date = date;
        this.time = time;
    }
    
    public LocalDate getDate() {
        return this.date;
    }
    
    public LocalTime getTime() {
        return this.time;
    }
    
    public LocalDate setDate(LocalDate date) {
        return this.date = date;
    }
    
    public LocalTime setTime(LocalTime time) {
        return this.time = time;
    }

    @Override
    public String toString() {
        String dateString;
        String timeString;
        
        if (date == null) {
            dateString = "";
        } else {
            dateString = DateTimeUtil.prettyPrintDate(date);
        }
        
        if (time == null) {
            timeString = "";
        } else {
            timeString = DateTimeUtil.prettyPrintTime(time);
        }

        return dateString + " " + timeString;
    }

    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof TaskDate // instanceof handles nulls
                && ((this.date == null && ((TaskDate) other).date == null)
                || ((this.date != null && ((TaskDate) other).date != null)
                && DateTimeUtil.combineLocalDateAndTime(this.date, this.time)
                    .equals(DateTimeUtil.combineLocalDateAndTime(((TaskDate) other).date, ((TaskDate) other).time)))));
    }

    @Override
    public int hashCode() {
        return this.toString().hashCode();
    }

}
```
###### \java\seedu\todo\model\ToDoList.java
``` java
    private final Stack<UniqueTaskList> tasksHistory;
    private final Stack<UniqueTagList> tagsHistory;
```
###### \java\seedu\todo\model\ToDoList.java
``` java
    public void resetData(Collection<? extends ReadOnlyTask> newTasks, Collection<Tag> newTags) {
        setTasks(newTasks.stream().map(Task::new).collect(Collectors.toList()));
        setTags(newTags);
        
        for (Task t : this.getTasks()) {
            if (t.isRecurring() 
                    && (t.getOnDate().getDate().isBefore(LocalDate.now()) 
                    || t.getByDate().getDate().isBefore(LocalDate.now()))) {
                t.getRecurrence().updateTaskDate(t);
            }
        }
    }
```
###### \java\seedu\todo\model\ToDoList.java
``` java
    public void setTasks(List<Task> tasks) {
        if (this.tasksHistory.isEmpty()) {
            UniqueTaskList topList = this.copyTaskList(tasks);
            this.tasksHistory.push(topList);
        } else {
            UniqueTaskList topList = this.tasksHistory.pop();
            UniqueTaskList oldList = this.copyTaskList(topList.getInternalList());
            
            this.tasksHistory.push(oldList);
            topList.getInternalList().setAll(tasks);
            this.tasksHistory.push(topList);
        }
        
    }
```
###### \java\seedu\todo\model\ToDoList.java
``` java
    /**
     * Adds a task to the to do list.
     * Also checks the new task's tags and updates {@link #tags} with any new tags found,
     * and updates the Tag objects in the task to point to those in {@link #tags}.
     *
     * @throws UniqueTaskList.DuplicateTaskException if an equivalent task already exists.
     */
    public void addTask(Task p) throws UniqueTaskList.DuplicateTaskException {
        UniqueTaskList topList = this.tasksHistory.pop();
        UniqueTaskList oldList = this.copyTaskList(topList.getInternalList());
        this.tasksHistory.push(oldList);
        this.tasksHistory.push(topList);
        topList.add(p);
        
    }
```
###### \java\seedu\todo\model\ToDoList.java
``` java
    public boolean removeTask(ReadOnlyTask key) throws UniqueTaskList.TaskNotFoundException {
        UniqueTaskList topList = this.tasksHistory.pop();
        UniqueTaskList oldList = this.copyTaskList(topList.getInternalList());
        this.tasksHistory.push(oldList);
        this.tasksHistory.push(topList);
        if (topList.remove(key)) {
            return true;
        } else {
            throw new UniqueTaskList.TaskNotFoundException();
        }
    }
    
    public boolean updateTask(ReadOnlyTask oldTask, ReadOnlyTask newTask) throws TaskNotFoundException {
        UniqueTaskList topList = this.tasksHistory.pop();
        UniqueTaskList oldList = this.copyTaskList(topList.getInternalList());
        this.tasksHistory.push(oldList);
        this.tasksHistory.push(topList);
        
        int index = getTasks().indexOf(oldTask);
        if (index < 0) {
            throw new TaskNotFoundException();
        } else {
            getTasks().get(index).setName(newTask.getName());
            getTasks().get(index).setDetail(newTask.getDetail());
            getTasks().get(index).setOnDate(newTask.getOnDate());
            getTasks().get(index).setByDate(newTask.getByDate());
            getTasks().get(index).setPriority(newTask.getPriority());
            getTasks().get(index).setRecurrence(newTask.getRecurrence());
            syncTagsWithMasterList(getTasks().get(index));
            return true;
        }
    }
    
    public void updateTaskTags(ReadOnlyTask oldTask, ReadOnlyTask newTask) throws TaskNotFoundException {
    	for (Tag t : newTask.getTags().getInternalList()) {
    		try {
    			this.getTags().add(t);	
    		}catch (Exception e) {
    			
    		}
    		
    	}
    }
    
    
    /**
     * Pop the top most UniqueTaskList.
     * TODO : Does not handle tags as of yet
     */
    public boolean undo() {
        if (this.tasksHistory.size() > 1) {
            UniqueTaskList topList = this.tasksHistory.pop();
            UniqueTaskList oldList = this.tasksHistory.pop();
            topList.getInternalList().setAll(oldList.getInternalList());
            this.tasksHistory.push(topList);
            return true;
        }
        return false;
    }

//// tag-level operations

    public void addTag(Tag t) throws UniqueTagList.DuplicateTagException {
        UniqueTagList newList = this.copyTagList(this.tagsHistory.peek().getInternalList());
        newList.add(t);
        this.tagsHistory.push(newList);
    }
```
###### \java\seedu\todo\model\ToDoList.java
``` java
    @Override
    public String toString() {
        return tasksHistory.peek().getInternalList().size() + " tasks, " 
                + tagsHistory.peek().getInternalList().size() +  " tags";
        // TODO: refine later
    }
```
###### \java\seedu\todo\model\ToDoList.java
``` java
    @Override
    public UniqueTaskList getUniqueTaskList() {
        return this.tasksHistory.peek();
    }

    @Override
    public UniqueTagList getUniqueTagList() {
        return this.tagsHistory.peek();
    }


    @Override
    public boolean equals(Object other) {
        return other == this // short circuit if same object
                || (other instanceof ToDoList // instanceof handles nulls
                && this.tasksHistory.peek().equals(((ToDoList) other).tasksHistory.peek())
                && this.tagsHistory.peek().equals(((ToDoList) other).tagsHistory.peek()));
    }
    
    @Override
    public int hashCode() {
        // use this method for custom fields hashing instead of implementing your own
        return Objects.hash(tasksHistory.peek(), tagsHistory.peek());
    }
    
    private UniqueTaskList copyTaskList(Collection<Task> old) {
        UniqueTaskList newList = new UniqueTaskList();

        for (Task t : old) {
            try {
                newList.add(new Task(t));
            } catch (UniqueTaskList.DuplicateTaskException e) {}
        }
        return newList;
    }
    
 
    private UniqueTagList copyTagList(Collection<Tag> old) {
        UniqueTagList newList = new UniqueTagList();
        
        for (Tag t : old) {
            try {
                newList.add(t);
            } catch (UniqueTagList.DuplicateTagException e) {}
        }
        return newList;
    }
    
}
```
###### \java\seedu\todo\ui\CommandBox.java
``` java
    private Stack<String> commandHistory = new Stack<>();
    private Stack<String> commandFuture = new Stack<>();
```
###### \java\seedu\todo\ui\CommandBox.java
``` java
    @FXML
    private void handleKeyPressed(KeyEvent e) {
        if (e.getCode().toString().equals("UP") && !commandHistory.isEmpty()) {
            String c = commandHistory.pop();
            commandFuture.push(c);
            commandTextField.setText(c);
        }
        if (e.getCode().toString().equals("DOWN") && !commandFuture.isEmpty()) {
            String c = commandFuture.pop();
            commandHistory.push(c);
            commandTextField.setText(c);
        }
    }
```
